# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `idlc` gem.
# Please instead update this file by running `bin/tapioca gem idlc`.


# source://idlc//lib/idlc/syntax_node.rb#48
module Idl
  include ::Treetop::Runtime

  # source://idlc//lib/idlc/idl_parser.rb#6275
  def _nt_ary_access; end

  # source://idlc//lib/idlc/idl_parser.rb#6173
  def _nt_ary_eligible_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#11858
  def _nt_ary_size_decl; end

  # source://idlc//lib/idlc/idl_parser.rb#11104
  def _nt_assignment; end

  # source://idlc//lib/idlc/idl_parser.rb#889
  def _nt_bitfield_definition; end

  # source://idlc//lib/idlc/idl_parser.rb#6576
  def _nt_bits_cast; end

  # source://idlc//lib/idlc/idl_parser.rb#9614
  def _nt_body_function_definition; end

  # source://idlc//lib/idlc/idl_parser.rb#10378
  def _nt_builtin_function_definition; end

  # source://idlc//lib/idlc/idl_parser.rb#16350
  def _nt_builtin_read_only_var; end

  # source://idlc//lib/idlc/idl_parser.rb#16374
  def _nt_builtin_read_write_var; end

  # source://idlc//lib/idlc/idl_parser.rb#14711
  def _nt_builtin_type_name; end

  # source://idlc//lib/idlc/idl_parser.rb#15960
  def _nt_comment; end

  # source://idlc//lib/idlc/idl_parser.rb#5747
  def _nt_concatenation_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#8614
  def _nt_constraint_body; end

  # source://idlc//lib/idlc/idl_parser.rb#5888
  def _nt_csr_field_access_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#16456
  def _nt_csr_field_name; end

  # source://idlc//lib/idlc/idl_parser.rb#16401
  def _nt_csr_name; end

  # source://idlc//lib/idlc/idl_parser.rb#5962
  def _nt_csr_register_access_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#12210
  def _nt_declaration; end

  # source://idlc//lib/idlc/idl_parser.rb#12650
  def _nt_dontcare_lvalue; end

  # source://idlc//lib/idlc/idl_parser.rb#12674
  def _nt_dontcare_return; end

  # source://idlc//lib/idlc/idl_parser.rb#468
  def _nt_enum_definition; end

  # source://idlc//lib/idlc/idl_parser.rb#780
  def _nt_enum_ref; end

  # source://idlc//lib/idlc/idl_parser.rb#6699
  def _nt_enum_to_a; end

  # source://idlc//lib/idlc/idl_parser.rb#13759
  def _nt_execute_if_block; end

  # source://idlc//lib/idlc/idl_parser.rb#8704
  def _nt_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#10833
  def _nt_fetch; end

  # source://idlc//lib/idlc/idl_parser.rb#6058
  def _nt_field_access_eligible_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#6106
  def _nt_field_access_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#15834
  def _nt_field_name; end

  # source://idlc//lib/idlc/idl_parser.rb#14368
  def _nt_for_loop; end

  # source://idlc//lib/idlc/idl_parser.rb#12078
  def _nt_for_loop_iteration_variable_declaration; end

  # source://idlc//lib/idlc/idl_parser.rb#9432
  def _nt_function_arg_list; end

  # source://idlc//lib/idlc/idl_parser.rb#16108
  def _nt_function_body; end

  # source://idlc//lib/idlc/idl_parser.rb#8917
  def _nt_function_call; end

  # source://idlc//lib/idlc/idl_parser.rb#8784
  def _nt_function_call_template_arguments; end

  # source://idlc//lib/idlc/idl_parser.rb#10929
  def _nt_function_definition; end

  # source://idlc//lib/idlc/idl_parser.rb#13101
  def _nt_function_if_block; end

  # source://idlc//lib/idlc/idl_parser.rb#9337
  def _nt_function_name; end

  # source://idlc//lib/idlc/idl_parser.rb#16051
  def _nt_function_statement; end

  # source://idlc//lib/idlc/idl_parser.rb#290
  def _nt_global_definition; end

  # source://idlc//lib/idlc/idl_parser.rb#16286
  def _nt_id; end

  # source://idlc//lib/idlc/idl_parser.rb#8031
  def _nt_implication_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#8248
  def _nt_implication_for_loop; end

  # source://idlc//lib/idlc/idl_parser.rb#8551
  def _nt_implication_statement; end

  # source://idlc//lib/idlc/idl_parser.rb#196
  def _nt_include_statement; end

  # source://idlc//lib/idlc/idl_parser.rb#16192
  def _nt_instruction_operation; end

  # source://idlc//lib/idlc/idl_parser.rb#1529
  def _nt_int; end

  # source://idlc//lib/idlc/idl_parser.rb#26
  def _nt_isa; end

  # source://idlc//lib/idlc/idl_parser.rb#15088
  def _nt_keyword; end

  # source://idlc//lib/idlc/idl_parser.rb#3517
  def _nt_p0_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#2897
  def _nt_p0_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#3635
  def _nt_p1_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#2965
  def _nt_p1_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#3753
  def _nt_p2_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3033
  def _nt_p2_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#3871
  def _nt_p3_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3101
  def _nt_p3_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#3169
  def _nt_p3_template_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#4107
  def _nt_p4_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3213
  def _nt_p4_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#4343
  def _nt_p5_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3260
  def _nt_p5_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#4579
  def _nt_p6_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3313
  def _nt_p6_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#4815
  def _nt_p7_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3340
  def _nt_p7_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#5051
  def _nt_p8_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3393
  def _nt_p8_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#5287
  def _nt_p9_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3417
  def _nt_p9_binary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#5510
  def _nt_paren_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#6462
  def _nt_post_dec; end

  # source://idlc//lib/idlc/idl_parser.rb#6519
  def _nt_post_inc; end

  # source://idlc//lib/idlc/idl_parser.rb#5594
  def _nt_replication_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#15918
  def _nt_reserved; end

  # source://idlc//lib/idlc/idl_parser.rb#12726
  def _nt_return_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#12908
  def _nt_return_statement; end

  # source://idlc//lib/idlc/idl_parser.rb#10961
  def _nt_rval; end

  # source://idlc//lib/idlc/idl_parser.rb#12382
  def _nt_single_declaration; end

  # source://idlc//lib/idlc/idl_parser.rb#11949
  def _nt_single_declaration_with_initialization; end

  # source://idlc//lib/idlc/idl_parser.rb#16726
  def _nt_space; end

  # source://idlc//lib/idlc/idl_parser.rb#12480
  def _nt_statement; end

  # source://idlc//lib/idlc/idl_parser.rb#16631
  def _nt_string; end

  # source://idlc//lib/idlc/idl_parser.rb#1213
  def _nt_struct_definition; end

  # source://idlc//lib/idlc/idl_parser.rb#8736
  def _nt_template_safe_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3989
  def _nt_template_safe_p3_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#4225
  def _nt_template_safe_p4_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#4461
  def _nt_template_safe_p5_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#4697
  def _nt_template_safe_p6_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#4933
  def _nt_template_safe_p7_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#5169
  def _nt_template_safe_p8_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#5405
  def _nt_template_safe_p9_binary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#7903
  def _nt_template_safe_ternary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#7782
  def _nt_ternary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#15886
  def _nt_type_name; end

  # source://idlc//lib/idlc/idl_parser.rb#6866
  def _nt_unary_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#3441
  def _nt_unary_operator; end

  # source://idlc//lib/idlc/idl_parser.rb#15767
  def _nt_user_type_name; end

  # source://idlc//lib/idlc/idl_parser.rb#16515
  def _nt_var_write; end

  # source://idlc//lib/idlc/idl_parser.rb#1397
  def _nt_version_string; end

  # source://idlc//lib/idlc/idl_parser.rb#12
  def root; end

  class << self
    # source://idlc//lib/idlc/log.rb#15
    sig { returns(::Logger) }
    def logger; end

    # source://idlc//lib/idlc/log.rb#20
    sig { params(logger: ::Logger).returns(::Logger) }
    def set_logger(logger); end
  end
end

# source://idlc//lib/idlc/ast.rb#1379
class Idl::ArrayIncludesAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#1389
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      ary: T.all(::Idl::AstNode, ::Idl::Rvalue),
      value: T.all(::Idl::AstNode, ::Idl::Rvalue)
    ).void
  end
  def initialize(input, interval, ary, value); end

  # source://idlc//lib/idlc/ast.rb#1383
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def ary; end

  # source://idlc//lib/idlc/ast.rb#1417
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1386
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def expr; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#305
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#1423
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1420
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/../../udb/lib/udb/idl/condition_to_udb.rb#142
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#1407
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1394
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1412
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1431
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1373
class Idl::ArrayIncludesSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1374
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#5274
class Idl::ArrayLiteralAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#5278
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#5282
  def element_nodes; end

  # source://idlc//lib/idlc/ast.rb#5280
  def entries; end

  # source://idlc//lib/idlc/ast.rb#5309
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#5306
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5297
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5287
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#5301
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5316
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ArrayLiteralAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5268
class Idl::ArrayLiteralSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5269
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#1450
class Idl::ArraySizeAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#1459
  def initialize(input, interval, expression); end

  # source://idlc//lib/idlc/ast.rb#1457
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1454
  def expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#299
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#1491
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1488
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1470
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1463
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1481
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Integer) }
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1498
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1444
class Idl::ArraySizeSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1445
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#6247
module Idl::AryAccess0
  # source://idlc//lib/idlc/idl_parser.rb#6248
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#6254
module Idl::AryAccess1
  # source://idlc//lib/idlc/idl_parser.rb#6259
  def lsb; end

  # source://idlc//lib/idlc/idl_parser.rb#6255
  def msb; end
end

# source://idlc//lib/idlc/idl_parser.rb#6265
module Idl::AryAccess2
  # source://idlc//lib/idlc/idl_parser.rb#6266
  def a; end

  # source://idlc//lib/idlc/idl_parser.rb#6270
  def brackets; end
end

# source://idlc//lib/idlc/ast.rb#2385
class Idl::AryAccessSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2389
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#2405
class Idl::AryElementAccessAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#2420
  def initialize(input, interval, var, index); end

  # source://idlc//lib/idlc/ast.rb#2409
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#229
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2418
  def index; end

  # source://idlc//lib/idlc/ast.rb#2493
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#2490
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/../../udb/lib/udb/idl/condition_to_udb.rb#113
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#2455
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#2425
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#2470
  def value(symtab); end

  # source://idlc//lib/idlc/ast.rb#2417
  def var; end

  class << self
    # source://idlc//lib/idlc/ast.rb#2501
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#2808
class Idl::AryElementAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#2830
  def initialize(input, interval, lhs, idx, rhs); end

  # source://idlc//lib/idlc/ast.rb#2812
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#2869
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#2899
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#253
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2827
  def idx; end

  # source://idlc//lib/idlc/ast.rb#2826
  def lhs; end

  # source://idlc//lib/idlc/ast.rb#2828
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#2937
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#2934
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2835
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#2946
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AryElementAssignmentAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#2798
class Idl::AryElementAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2799
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#2514
class Idl::AryRangeAccessAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#2532
  def initialize(input, interval, var, msb, lsb); end

  # source://idlc//lib/idlc/ast.rb#2518
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#168
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2530
  def lsb; end

  # source://idlc//lib/idlc/ast.rb#2529
  def msb; end

  # source://idlc//lib/idlc/ast.rb#2588
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#2585
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2562
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#2537
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#2578
  def value(symtab); end

  # source://idlc//lib/idlc/ast.rb#2528
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def var; end

  class << self
    # source://idlc//lib/idlc/ast.rb#2599
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#2970
class Idl::AryRangeAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#2993
  def initialize(input, interval, variable, msb, lsb, write_value); end

  # source://idlc//lib/idlc/ast.rb#2974
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#3030
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#3058
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#20
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2990
  def lsb; end

  # source://idlc//lib/idlc/ast.rb#2989
  def msb; end

  # source://idlc//lib/idlc/ast.rb#3025
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#3067
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#3064
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2998
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#2988
  def variable; end

  # source://idlc//lib/idlc/ast.rb#2991
  def write_value; end

  class << self
    # source://idlc//lib/idlc/ast.rb#3079
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AryRangeAssignmentAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#2960
class Idl::AryRangeAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2961
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#11851
module Idl::ArySizeDecl0
  # source://idlc//lib/idlc/idl_parser.rb#11852
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#11011
module Idl::Assignment0
  # source://idlc//lib/idlc/idl_parser.rb#11012
  def var; end
end

# source://idlc//lib/idlc/idl_parser.rb#11018
module Idl::Assignment1
  # source://idlc//lib/idlc/idl_parser.rb#11019
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#11027
  def function_call; end

  # source://idlc//lib/idlc/idl_parser.rb#11023
  def rest; end
end

# source://idlc//lib/idlc/idl_parser.rb#11032
module Idl::Assignment2
  # source://idlc//lib/idlc/idl_parser.rb#11033
  def rval; end
end

# source://idlc//lib/idlc/idl_parser.rb#11038
module Idl::Assignment3
  # source://idlc//lib/idlc/idl_parser.rb#11043
  def rval; end

  # source://idlc//lib/idlc/idl_parser.rb#11039
  def var; end
end

# source://idlc//lib/idlc/idl_parser.rb#11048
module Idl::Assignment4
  # source://idlc//lib/idlc/idl_parser.rb#11049
  def csr_field_access_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#11053
  def rval; end
end

# source://idlc//lib/idlc/idl_parser.rb#11058
module Idl::Assignment5
  # source://idlc//lib/idlc/idl_parser.rb#11063
  def field_name; end

  # source://idlc//lib/idlc/idl_parser.rb#11059
  def id; end

  # source://idlc//lib/idlc/idl_parser.rb#11067
  def rval; end
end

# source://idlc//lib/idlc/idl_parser.rb#11072
module Idl::Assignment6
  # source://idlc//lib/idlc/idl_parser.rb#11081
  def lsb; end

  # source://idlc//lib/idlc/idl_parser.rb#11077
  def msb; end

  # source://idlc//lib/idlc/idl_parser.rb#11085
  def rval; end

  # source://idlc//lib/idlc/idl_parser.rb#11073
  def var; end
end

# source://idlc//lib/idlc/idl_parser.rb#11090
module Idl::Assignment7
  # source://idlc//lib/idlc/idl_parser.rb#11095
  def idx; end

  # source://idlc//lib/idlc/idl_parser.rb#11099
  def rval; end

  # source://idlc//lib/idlc/idl_parser.rb#11091
  def var; end
end

# source://idlc//lib/idlc/type.rb#11
class Idl::AstNode
  abstract!

  # source://idlc//lib/idlc/ast.rb#210
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      children: T::Array[::Idl::AstNode]
    ).void
  end
  def initialize(input, interval, children); end

  # source://idlc//lib/idlc/ast.rb#86
  sig { returns(T::Array[::Idl::AstNode]) }
  def children; end

  # source://idlc//lib/idlc/ast.rb#204
  sig { abstract.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#261
  sig { params(klass: ::Class).returns(T.nilable(::Idl::AstNode)) }
  def find_ancestor(klass); end

  # source://idlc//lib/idlc/ast.rb#438
  sig { params(global_symtab: ::Idl::SymbolTable).returns(::Idl::AstNode) }
  def freeze_tree(global_symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#10
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#16
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#64
  sig { returns(T.nilable(::String)) }
  def input; end

  # source://idlc//lib/idlc/ast.rb#56
  sig { returns(::Pathname) }
  def input_file; end

  # source://idlc//lib/idlc/ast.rb#595
  sig { returns(::String) }
  def inspect; end

  # source://idlc//lib/idlc/ast.rb#372
  sig { params(reason: ::String).returns(T.noreturn) }
  def internal_error(reason); end

  # source://idlc//lib/idlc/ast.rb#68
  sig { returns(T.nilable(T::Range[::Integer])) }
  def interval; end

  # source://idlc//lib/idlc/ast.rb#254
  sig { returns(::Integer) }
  def lineno; end

  # source://idlc//lib/idlc/ast.rb#279
  sig { returns(::Idl::AstNode::LinesDescriptor) }
  def lines_around; end

  # source://idlc//lib/idlc/passes/prune.rb#64
  def nullify_assignments(symtab); end

  # source://idlc//lib/idlc/ast.rb#82
  sig { returns(T.nilable(::Idl::AstNode)) }
  def parent; end

  # source://idlc//lib/idlc/passes/find_return_values.rb#11
  def pass_find_return_values(values, current_conditions); end

  # source://idlc//lib/idlc/ast.rb#447
  sig { returns(::String) }
  def path; end

  # source://idlc//lib/idlc/ast.rb#421
  sig { params(indent: ::Integer, indent_size: ::Integer, io: ::IO).void }
  def print_ast(indent = T.unsafe(nil), indent_size: T.unsafe(nil), io: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/prune.rb#45
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#13
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#12
  def reachable_functions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#243
  sig { params(filename: T.any(::Pathname, ::String), starting_line: ::Integer).void }
  def set_input_file(filename, starting_line = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#227
  sig { params(filename: T.any(::Pathname, ::String), starting_line: ::Integer).void }
  def set_input_file_unless_already_set(filename, starting_line = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#486
  sig { returns(T::Hash[::String, T.untyped]) }
  def source_yaml; end

  # source://idlc//lib/idlc/ast.rb#60
  sig { returns(::Integer) }
  def starting_line; end

  # source://idlc//lib/idlc/ast.rb#72
  sig { returns(::String) }
  def text_value; end

  # source://idlc//lib/idlc/ast.rb#512
  sig { abstract.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#479
  sig { abstract.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#482
  sig { overridable.returns(::String) }
  def to_idl_verbose; end

  # source://udb/0.1.0/../../udb/lib/udb/idl/condition_to_udb.rb#18
  sig { overridable.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#307
  sig { params(reason: ::String).void }
  def truncation_warn(reason); end

  # source://idlc//lib/idlc/ast.rb#469
  sig { abstract.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#323
  sig { params(reason: ::String).returns(T.noreturn) }
  def type_error(reason); end

  # source://idlc//lib/idlc/ast.rb#411
  sig { params(s: ::String).returns(::String) }
  def unindent(s); end

  # source://idlc//lib/idlc/ast.rb#198
  sig { params(value_result: T.untyped, block: T.proc.returns(T.untyped)).returns(T.untyped) }
  def value_else(value_result, &block); end

  # source://idlc//lib/idlc/ast.rb#402
  sig { params(reason: ::String).returns(T.noreturn) }
  def value_error(reason); end

  # source://idlc//lib/idlc/ast.rb#188
  sig { params(block: T.proc.params(arg0: ::Object).returns(T.untyped)).returns(T.untyped) }
  def value_try(&block); end

  class << self
    # source://idlc//lib/idlc/ast.rb#515
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end

    # source://idlc//lib/idlc/ast.rb#495
    sig { params(yaml: T::Hash[::String, T.untyped]).returns(T::Array[T.any(::String, T::Range[::Integer])]) }
    def from_source_yaml(yaml); end

    # source://idlc//lib/idlc/ast.rb#501
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(T.nilable(::String))
    end
    def input_from_source_yaml(yaml, source_mapper); end

    # source://idlc//lib/idlc/ast.rb#507
    sig { params(yaml: T::Hash[::String, T.untyped]).returns(T.nilable(T::Range[::Integer])) }
    def interval_from_source_yaml(yaml); end

    # source://idlc//lib/idlc/ast.rb#191
    sig { params(value_result: T.untyped, _block: T.proc.returns(T.untyped)).returns(T.untyped) }
    def value_else(value_result, &_block); end

    # source://idlc//lib/idlc/ast.rb#393
    sig { params(reason: ::String, ast: T.nilable(::Idl::AstNode)).returns(T.noreturn) }
    def value_error(reason, ast = T.unsafe(nil)); end

    # source://idlc//lib/idlc/ast.rb#385
    def value_error_ast; end

    # source://idlc//lib/idlc/ast.rb#385
    def value_error_ast=(_arg0); end

    # source://idlc//lib/idlc/ast.rb#385
    def value_error_reason; end

    # source://idlc//lib/idlc/ast.rb#385
    def value_error_reason=(_arg0); end

    # source://idlc//lib/idlc/ast.rb#184
    sig { params(block: T.proc.params(arg0: ::Object).returns(T.untyped)).returns(T.untyped) }
    def value_try(&block); end
  end
end

# source://idlc//lib/idlc/ast.rb#43
Idl::AstNode::Bits1Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#45
Idl::AstNode::Bits32Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#47
Idl::AstNode::Bits64Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#50
Idl::AstNode::BoolType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#49
Idl::AstNode::ConstBoolType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#119
class Idl::AstNode::InternalError < ::StandardError
  # source://idlc//lib/idlc/ast.rb#135
  sig { params(what: ::String).void }
  def initialize(what); end

  # source://idlc//lib/idlc/ast.rb#132
  sig { returns(T::Array[::String]) }
  def bt; end

  # source://idlc//lib/idlc/ast.rb#124
  sig { returns(::String) }
  def what; end
end

# source://idlc//lib/idlc/ast.rb#271
class Idl::AstNode::LinesDescriptor < ::T::Struct
  const :lines, ::String
  const :problem_interval, T::Range[T.untyped]
  const :lines_interval, T::Range[T.untyped]

  class << self
    # source://sorbet-runtime/0.6.12690/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://idlc//lib/idlc/ast.rb#44
Idl::AstNode::PossiblyUnknownBits1Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#46
Idl::AstNode::PossiblyUnknownBits32Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#48
Idl::AstNode::PossiblyUnknownBits64Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#52
Idl::AstNode::StringType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#89
class Idl::AstNode::TypeError < ::StandardError
  # source://idlc//lib/idlc/ast.rb#106
  sig { params(what: ::String).void }
  def initialize(what); end

  # source://idlc//lib/idlc/ast.rb#102
  sig { returns(T::Array[::String]) }
  def bt; end

  # source://idlc//lib/idlc/ast.rb#94
  sig { returns(::String) }
  def what; end
end

# source://idlc//lib/idlc/ast.rb#149
class Idl::AstNode::ValueError < ::StandardError
  # source://idlc//lib/idlc/ast.rb#162
  sig { params(lineno: ::Integer, file: ::String, reason: ::String).void }
  def initialize(lineno, file, reason); end

  # source://idlc//lib/idlc/ast.rb#156
  sig { returns(::String) }
  def file; end

  # source://idlc//lib/idlc/ast.rb#153
  sig { returns(::Integer) }
  def lineno; end

  # source://idlc//lib/idlc/ast.rb#173
  sig { returns(::String) }
  def message; end

  # source://idlc//lib/idlc/ast.rb#159
  sig { returns(::String) }
  def reason; end

  # source://idlc//lib/idlc/ast.rb#170
  sig { returns(::String) }
  def what; end
end

# source://idlc//lib/idlc/ast.rb#51
Idl::AstNode::VoidType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#16
Idl::BasicValueRbType = T.type_alias { T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean) }

# source://idlc//lib/idlc/ast.rb#4407
class Idl::BinaryExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#4426
  def initialize(input, interval, lhs, op, rhs); end

  # source://idlc//lib/idlc/ast.rb#4696
  def bits_needed(value, signed); end

  # source://idlc//lib/idlc/ast.rb#4416
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#235
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#4433
  def invert(symtab); end

  # source://idlc//lib/idlc/ast.rb#4422
  def lhs; end

  # source://idlc//lib/idlc/ast.rb#4723
  def max_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#4866
  def min_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#5210
  def op; end

  # source://idlc//lib/idlc/passes/prune.rb#239
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#4423
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#4469
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#4464
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/../../udb/lib/udb/idl/condition_to_udb.rb#201
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#4492
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#4592
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#5016
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#4478
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::BinaryExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#4412
Idl::BinaryExpressionAst::ARITH_OPS = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/ast.rb#4411
Idl::BinaryExpressionAst::BIT_OPS = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/ast.rb#4410
Idl::BinaryExpressionAst::LOGICAL_OPS = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/ast.rb#4413
Idl::BinaryExpressionAst::OPS = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/ast.rb#3952
class Idl::BinaryExpressionRightSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3956
  def to_ast; end

  # source://idlc//lib/idlc/ast.rb#3973
  def type_check(_symtab); end
end

# source://idlc//lib/idlc/idl_parser.rb#847
module Idl::BitfieldDefinition0
  # source://idlc//lib/idlc/idl_parser.rb#848
  def int; end
end

# source://idlc//lib/idlc/idl_parser.rb#853
module Idl::BitfieldDefinition1
  # source://idlc//lib/idlc/idl_parser.rb#854
  def int; end

  # source://idlc//lib/idlc/idl_parser.rb#858
  def lsb; end
end

# source://idlc//lib/idlc/idl_parser.rb#863
module Idl::BitfieldDefinition2
  # source://idlc//lib/idlc/idl_parser.rb#864
  def field_name; end

  # source://idlc//lib/idlc/idl_parser.rb#868
  def range; end
end

# source://idlc//lib/idlc/idl_parser.rb#874
module Idl::BitfieldDefinition3
  # source://idlc//lib/idlc/idl_parser.rb#883
  def e; end

  # source://idlc//lib/idlc/idl_parser.rb#875
  def int; end

  # source://idlc//lib/idlc/idl_parser.rb#879
  def user_type_name; end
end

# source://idlc//lib/idlc/ast.rb#2117
class Idl::BitfieldDefinitionAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#2123
  def initialize(input, interval, name, size, fields); end

  # source://idlc//lib/idlc/ast.rb#2176
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#2121
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#2148
  def element_names; end

  # source://idlc//lib/idlc/ast.rb#2156
  def element_ranges(symtab); end

  # source://idlc//lib/idlc/ast.rb#2132
  def freeze_tree(global_symtab); end

  # source://idlc//lib/idlc/ast.rb#2198
  def name; end

  # source://idlc//lib/idlc/ast.rb#2143
  def size(symtab); end

  # source://idlc//lib/idlc/ast.rb#2215
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#2205
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2186
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#2163
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#2201
  def value(_symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#2224
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#2086
class Idl::BitfieldDefinitionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2087
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#2001
class Idl::BitfieldFieldDefinitionAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#2008
  def initialize(input, interval, name, msb, lsb); end

  # source://idlc//lib/idlc/ast.rb#2006
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#2003
  def name; end

  # source://idlc//lib/idlc/ast.rb#2043
  def range(symtab); end

  # source://idlc//lib/idlc/ast.rb#2061
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#2052
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2021
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#2072
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/type.rb#696
class Idl::BitfieldType < ::Idl::Type
  # source://idlc//lib/idlc/type.rb#697
  def initialize(type_name, width, field_names, field_ranges); end

  # source://idlc//lib/idlc/type.rb#717
  def clone; end

  # source://idlc//lib/idlc/type.rb#713
  def field_names; end

  # source://idlc//lib/idlc/type.rb#706
  def range(field_name); end
end

# source://idlc//lib/idlc/type.rb#981
Idl::Bits1Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/type.rb#982
Idl::Bits32Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/type.rb#983
Idl::Bits64Type = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/idl_parser.rb#6569
module Idl::BitsCast0
  # source://idlc//lib/idlc/idl_parser.rb#6570
  def expr; end
end

# source://idlc//lib/idlc/ast.rb#4318
class Idl::BitsCastAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#4329
  def initialize(input, interval, exp); end

  # source://idlc//lib/idlc/ast.rb#4322
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4327
  def expr; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#102
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#4388
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#4385
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#4341
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#4332
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#4362
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#4395
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::BitsCastAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#4307
class Idl::BitsCastSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4308
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#984
Idl::BitsUnknownType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/idl_parser.rb#9522
module Idl::BodyFunctionDefinition0; end

# source://idlc//lib/idlc/idl_parser.rb#9525
module Idl::BodyFunctionDefinition1
  # source://idlc//lib/idlc/idl_parser.rb#9526
  def single_declaration; end
end

# source://idlc//lib/idlc/idl_parser.rb#9531
module Idl::BodyFunctionDefinition2
  # source://idlc//lib/idlc/idl_parser.rb#9532
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#9536
  def rest; end
end

# source://idlc//lib/idlc/idl_parser.rb#9542
module Idl::BodyFunctionDefinition3
  # source://idlc//lib/idlc/idl_parser.rb#9543
  def type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#9548
module Idl::BodyFunctionDefinition4
  # source://idlc//lib/idlc/idl_parser.rb#9549
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#9553
  def rest; end
end

# source://idlc//lib/idlc/idl_parser.rb#9559
module Idl::BodyFunctionDefinition5
  # source://idlc//lib/idlc/idl_parser.rb#9560
  def single_declaration; end
end

# source://idlc//lib/idlc/idl_parser.rb#9565
module Idl::BodyFunctionDefinition6
  # source://idlc//lib/idlc/idl_parser.rb#9566
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#9570
  def rest; end
end

# source://idlc//lib/idlc/idl_parser.rb#9576
module Idl::BodyFunctionDefinition7
  # source://idlc//lib/idlc/idl_parser.rb#9577
  def function_body; end
end

# source://idlc//lib/idlc/idl_parser.rb#9583
module Idl::BodyFunctionDefinition8
  # source://idlc//lib/idlc/idl_parser.rb#9600
  def args; end

  # source://idlc//lib/idlc/idl_parser.rb#9608
  def body_block; end

  # source://idlc//lib/idlc/idl_parser.rb#9604
  def desc; end

  # source://idlc//lib/idlc/idl_parser.rb#9588
  def function_name; end

  # source://idlc//lib/idlc/idl_parser.rb#9596
  def ret; end

  # source://idlc//lib/idlc/idl_parser.rb#9592
  def targs; end

  # source://idlc//lib/idlc/idl_parser.rb#9584
  def type; end
end

# source://idlc//lib/idlc/type.rb#987
Idl::BoolType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#1936
class Idl::BuiltinEnumDefinitionAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#1943
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      user_type: ::Idl::UserTypeNameAst
    ).void
  end
  def initialize(input, interval, user_type); end

  # source://idlc//lib/idlc/ast.rb#1970
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#1940
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1956
  def element_names(symtab); end

  # source://idlc//lib/idlc/ast.rb#1960
  def element_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#1975
  def name; end

  # source://idlc//lib/idlc/ast.rb#1982
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1979
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1965
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1949
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1989
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1925
class Idl::BuiltinEnumDefinitionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1926
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#10331
module Idl::BuiltinFunctionDefinition0
  # source://idlc//lib/idlc/idl_parser.rb#10332
  def first; end
end

# source://idlc//lib/idlc/idl_parser.rb#10338
module Idl::BuiltinFunctionDefinition1
  # source://idlc//lib/idlc/idl_parser.rb#10339
  def single_declaration; end
end

# source://idlc//lib/idlc/idl_parser.rb#10344
module Idl::BuiltinFunctionDefinition2
  # source://idlc//lib/idlc/idl_parser.rb#10345
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#10349
  def rest; end
end

# source://idlc//lib/idlc/idl_parser.rb#10355
module Idl::BuiltinFunctionDefinition3
  # source://idlc//lib/idlc/idl_parser.rb#10368
  def args; end

  # source://idlc//lib/idlc/idl_parser.rb#10372
  def desc; end

  # source://idlc//lib/idlc/idl_parser.rb#10360
  def function_name; end

  # source://idlc//lib/idlc/idl_parser.rb#10364
  def ret; end

  # source://idlc//lib/idlc/idl_parser.rb#10356
  def type; end
end

# source://idlc//lib/idlc/idl_parser.rb#14689
module Idl::BuiltinTypeName0; end

# source://idlc//lib/idlc/idl_parser.rb#14692
module Idl::BuiltinTypeName1
  # source://idlc//lib/idlc/idl_parser.rb#14693
  def i; end
end

# source://idlc//lib/idlc/idl_parser.rb#14699
module Idl::BuiltinTypeName2; end

# source://idlc//lib/idlc/idl_parser.rb#14702
module Idl::BuiltinTypeName3; end

# source://idlc//lib/idlc/idl_parser.rb#14705
module Idl::BuiltinTypeName4; end

# source://idlc//lib/idlc/idl_parser.rb#14708
module Idl::BuiltinTypeName5; end

# source://idlc//lib/idlc/ast.rb#6884
class Idl::BuiltinTypeNameAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#6891
  def initialize(input, interval, type_name, bits_expression); end

  # source://idlc//lib/idlc/ast.rb#6889
  def bits_expression; end

  # source://idlc//lib/idlc/ast.rb#6887
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6918
  def freeze_tree(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#192
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#6980
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6971
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6937
  sig { params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#6901
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6997
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::BuiltinTypeNameAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6863
class Idl::BuiltinTypeNameSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6864
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#5590
class Idl::BuiltinVariableAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#5609
  sig { params(input: T.nilable(::String), interval: T.nilable(T::Range[::Integer]), name: ::String).void }
  def initialize(input, interval, name); end

  # source://idlc//lib/idlc/ast.rb#5594
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#213
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5605
  def name; end

  # source://idlc//lib/idlc/ast.rb#5606
  def text_value; end

  # source://idlc//lib/idlc/ast.rb#5641
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#5638
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5618
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5614
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#5633
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5648
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::BuiltinVariableAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5660
class Idl::BuiltinVariableSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5661
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#15950
module Idl::Comment0; end

# source://idlc//lib/idlc/idl_parser.rb#15953
module Idl::Comment1
  # source://idlc//lib/idlc/idl_parser.rb#15954
  def content; end
end

# source://idlc//lib/idlc/ast.rb#6821
class Idl::CommentAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#6825
  def initialize(input, interval, text); end

  # source://idlc//lib/idlc/ast.rb#6823
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6838
  def content; end

  # source://idlc//lib/idlc/ast.rb#6830
  def text_value; end

  # source://idlc//lib/idlc/ast.rb#6844
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6841
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6833
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6851
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::CommentAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6816
class Idl::CommentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6817
  def to_ast; end
end

# source://idlc//lib/idlc.rb#63
class Idl::Compiler
  # source://idlc//lib/idlc.rb#68
  def initialize; end

  # source://idlc//lib/idlc.rb#376
  sig { params(body: ::String, symtab: ::Idl::SymbolTable, pass_error: T::Boolean).returns(::Idl::ConstraintBodyAst) }
  def compile_constraint(body, symtab, pass_error: T.unsafe(nil)); end

  # source://idlc//lib/idlc.rb#332
  def compile_expression(expression, symtab, pass_error: T.unsafe(nil)); end

  # source://idlc//lib/idlc.rb#84
  def compile_file(path, source_mapper = T.unsafe(nil)); end

  # source://idlc//lib/idlc.rb#151
  sig { params(loop: ::String, symtab: ::Idl::SymbolTable, pass_error: T::Boolean).returns(::Idl::ForLoopAst) }
  def compile_for_loop(loop, symtab, pass_error: T.unsafe(nil)); end

  # source://idlc//lib/idlc.rb#204
  def compile_func_body(body, return_type: T.unsafe(nil), symtab: T.unsafe(nil), name: T.unsafe(nil), input_file: T.unsafe(nil), input_line: T.unsafe(nil), no_rescue: T.unsafe(nil), extra_syms: T.unsafe(nil), type_check: T.unsafe(nil)); end

  # source://idlc//lib/idlc.rb#293
  def compile_inst_operation(inst, symtab:, input_file: T.unsafe(nil), input_line: T.unsafe(nil)); end

  # source://idlc//lib/idlc.rb#266
  def compile_inst_scope(idl, symtab:, input_file:, input_line: T.unsafe(nil)); end

  # source://idlc//lib/idlc.rb#66
  def parser; end

  # source://idlc//lib/idlc.rb#73
  def pb=(pb); end

  # source://idlc//lib/idlc.rb#304
  def type_check(ast, symtab, what); end

  # source://idlc//lib/idlc.rb#79
  def unset_pb; end

  class << self
    # source://idlc//lib/idlc/version.rb#8
    def version; end
  end
end

# source://idlc//lib/idlc/idl_parser.rb#5730
module Idl::ConcatenationExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5731
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#5736
module Idl::ConcatenationExpression1
  # source://idlc//lib/idlc/idl_parser.rb#5737
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#5741
  def rest; end
end

# source://idlc//lib/idlc/ast.rb#5338
class Idl::ConcatenationExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#5342
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#5344
  def expressions; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#97
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5410
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#5407
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5360
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5347
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#5395
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5417
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ConcatenationExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5328
class Idl::ConcatenationExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5329
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#6736
class Idl::ConditionalReturnStatementAst < ::Idl::AstNode
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#6745
  def initialize(input, interval, return_expression, condition); end

  # source://idlc//lib/idlc/ast.rb#6743
  def condition; end

  # source://idlc//lib/idlc/ast.rb#6740
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#25
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/prune.rb#413
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#150
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#137
  def reachable_functions(symtab, cache); end

  # source://idlc//lib/idlc/ast.rb#6742
  def return_expression; end

  # source://idlc//lib/idlc/ast.rb#6757
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#6762
  def return_types(symtab); end

  # source://idlc//lib/idlc/ast.rb#6768
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#6777
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#6794
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6791
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6750
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6802
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ConditionalReturnStatementAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6730
class Idl::ConditionalReturnStatementSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6731
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#6345
class Idl::ConditionalStatementAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#6352
  def initialize(input, interval, action, condition); end

  # source://idlc//lib/idlc/ast.rb#6346
  def action; end

  # source://idlc//lib/idlc/ast.rb#6347
  def condition; end

  # source://idlc//lib/idlc/ast.rb#6350
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6366
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#6382
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#283
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/prune.rb#428
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#166
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#154
  def reachable_functions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#6393
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6388
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6357
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6401
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ConditionalStatementAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6335
class Idl::ConditionalStatementSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6336
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#985
Idl::ConstBitsUnknownType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/type.rb#986
Idl::ConstBoolType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/idl_parser.rb#8601
module Idl::ConstraintBody0
  # source://idlc//lib/idlc/idl_parser.rb#8602
  def i; end
end

# source://idlc//lib/idlc/idl_parser.rb#8608
module Idl::ConstraintBody1
  # source://idlc//lib/idlc/idl_parser.rb#8609
  def b; end
end

# source://idlc//lib/idlc/ast.rb#4121
class Idl::ConstraintBodyAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#4129
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      stmts: T::Array[T.any(::Idl::ForLoopAst, ::Idl::ImplicationStatementAst)]
    ).void
  end
  def initialize(input, interval, stmts); end

  # source://idlc//lib/idlc/ast.rb#4134
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4147
  sig { params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def satisfied?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4137
  sig { returns(T::Array[T.any(::Idl::ForLoopAst, ::Idl::ImplicationStatementAst)]) }
  def stmts; end

  # source://idlc//lib/idlc/ast.rb#4159
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#4154
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/../../udb/lib/udb/idl/condition_to_udb.rb#53
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#4140
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#4166
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ConstraintBodyAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#4110
class Idl::ConstraintBodySyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4112
  sig { override.returns(::Idl::ConstraintBodyAst) }
  def to_ast; end
end

# source://idlc//lib/idlc/interfaces.rb#119
module Idl::Csr
  interface!

  # source://idlc//lib/idlc/interfaces.rb#134
  sig { abstract.returns(T::Boolean) }
  def dynamic_length?; end

  # source://idlc//lib/idlc/interfaces.rb#137
  sig { abstract.returns(T::Array[::Idl::CsrField]) }
  def fields; end

  # source://idlc//lib/idlc/interfaces.rb#128
  sig { abstract.params(base: T.nilable(::Integer)).returns(T.nilable(::Integer)) }
  def length(base); end

  # source://idlc//lib/idlc/interfaces.rb#131
  sig { abstract.returns(::Integer) }
  def max_length; end

  # source://idlc//lib/idlc/interfaces.rb#125
  sig { abstract.returns(::String) }
  def name; end

  # source://idlc//lib/idlc/interfaces.rb#142
  sig { abstract.returns(T.nilable(::Integer)) }
  def value; end
end

# source://idlc//lib/idlc/interfaces.rb#73
module Idl::CsrField
  interface!

  # source://idlc//lib/idlc/interfaces.rb#97
  sig { abstract.returns(T::Boolean) }
  def base32_only?; end

  # source://idlc//lib/idlc/interfaces.rb#93
  sig { abstract.returns(T::Boolean) }
  def base64_only?; end

  # source://idlc//lib/idlc/interfaces.rb#83
  sig { abstract.returns(T::Boolean) }
  def defined_in_all_bases?; end

  # source://idlc//lib/idlc/interfaces.rb#86
  sig { abstract.returns(T::Boolean) }
  def defined_in_base32?; end

  # source://idlc//lib/idlc/interfaces.rb#89
  sig { abstract.returns(T::Boolean) }
  def defined_in_base64?; end

  # source://idlc//lib/idlc/interfaces.rb#113
  sig { abstract.returns(T::Boolean) }
  def exists?; end

  # source://idlc//lib/idlc/interfaces.rb#102
  sig { abstract.params(base: T.nilable(::Integer)).returns(T::Range[::Integer]) }
  def location(base); end

  # source://idlc//lib/idlc/interfaces.rb#79
  sig { abstract.returns(::String) }
  def name; end

  # source://idlc//lib/idlc/interfaces.rb#116
  sig do
    abstract
      .returns(T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)]))
  end
  def reset_value; end

  # source://idlc//lib/idlc/interfaces.rb#108
  sig { abstract.params(base: T.nilable(::Integer)).returns(T.nilable(::String)) }
  def type(base); end

  # source://idlc//lib/idlc/interfaces.rb#105
  sig { abstract.params(base: T.nilable(::Integer)).returns(::Integer) }
  def width(base); end
end

# source://idlc//lib/idlc/idl_parser.rb#5878
module Idl::CsrFieldAccessExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5879
  def csr; end

  # source://idlc//lib/idlc/idl_parser.rb#5883
  def csr_field_name; end
end

# source://idlc//lib/idlc/ast.rb#3241
class Idl::CsrFieldAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#3251
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      csr_field: ::Idl::CsrFieldReadExpressionAst,
      write_value: T.all(::Idl::AstNode, ::Idl::Rvalue)
    ).void
  end
  def initialize(input, interval, csr_field, write_value); end

  # source://idlc//lib/idlc/ast.rb#3245
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#3247
  def csr_field; end

  # source://idlc//lib/idlc/ast.rb#3283
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#3288
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#3271
  def field(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#112
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#3294
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#3291
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#3255
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#3275
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#3248
  def write_value; end

  class << self
    # source://idlc//lib/idlc/ast.rb#3302
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::CsrFieldAssignmentAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#3235
class Idl::CsrFieldAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3236
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#16453
module Idl::CsrFieldName0; end

# source://idlc//lib/idlc/ast.rb#9292
class Idl::CsrFieldReadExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#9306
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      csr: ::Idl::CsrReadExpressionAst,
      field_name: ::String
    ).void
  end
  def initialize(input, interval, csr, field_name); end

  # source://idlc//lib/idlc/ast.rb#9387
  sig { params(symtab: ::Idl::SymbolTable).returns(T.nilable(::Idl::Type)) }
  def calc_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#9431
  sig { params(symtab: ::Idl::SymbolTable).void }
  def calc_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#9303
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#9335
  sig { params(symtab: ::Idl::SymbolTable).returns(::Idl::Csr) }
  def csr_def(symtab); end

  # source://idlc//lib/idlc/ast.rb#9340
  sig { returns(::String) }
  def csr_name; end

  # source://idlc//lib/idlc/ast.rb#9315
  sig { params(symtab: ::Idl::SymbolTable).returns(::Idl::Csr) }
  def csr_obj(symtab); end

  # source://idlc//lib/idlc/ast.rb#9343
  sig { params(symtab: ::Idl::SymbolTable).returns(::Idl::CsrField) }
  def field_def(symtab); end

  # source://idlc//lib/idlc/ast.rb#9348
  sig { params(symtab: ::Idl::SymbolTable).returns(::String) }
  def field_name(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#317
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#9359
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#9354
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#9381
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#9327
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#9419
  sig do
    override
      .params(
        symtab: ::Idl::SymbolTable
      ).returns(T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)]))
  end
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#9367
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::CsrFieldReadExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#9295
class Idl::CsrFieldReadExpressionAst::MemoizedState < ::T::Struct
  prop :csr, T.nilable(::Idl::Csr)
  prop :type, T.nilable(::Idl::Type)
  prop :value_calculated, T::Boolean
  prop :value, T.nilable(::Integer)

  class << self
    # source://sorbet-runtime/0.6.12690/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://idlc//lib/idlc/ast.rb#9452
class Idl::CsrFieldReadExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#9453
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#9620
class Idl::CsrFunctionCallAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#9638
  def initialize(input, interval, function_name, csr, args); end

  # source://idlc//lib/idlc/ast.rb#9636
  def args; end

  # source://idlc//lib/idlc/ast.rb#9624
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#9635
  def csr; end

  # source://idlc//lib/idlc/ast.rb#9676
  def csr_def(symtab); end

  # source://idlc//lib/idlc/ast.rb#9670
  def csr_known?(symtab); end

  # source://idlc//lib/idlc/ast.rb#9674
  def csr_name; end

  # source://idlc//lib/idlc/ast.rb#9633
  def function_name; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#76
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#9705
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#9700
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#9653
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#9643
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#9681
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#9714
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::CsrFunctionCallAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#9605
class Idl::CsrFunctionCallSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#9606
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#16398
module Idl::CsrName0; end

# source://idlc//lib/idlc/ast.rb#9458
class Idl::CsrReadExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#9466
  def initialize(input, interval, csr_name); end

  # source://idlc//lib/idlc/ast.rb#9462
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#9492
  def csr_def(symtab); end

  # source://idlc//lib/idlc/ast.rb#9496
  def csr_known?(symtab); end

  # source://idlc//lib/idlc/ast.rb#9464
  def csr_name; end

  # source://idlc//lib/idlc/ast.rb#9472
  def freeze_tree(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#325
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#9514
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#9511
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#9485
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#9488
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#9501
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#9521
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::CsrReadExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#9446
class Idl::CsrReadExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#9447
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#5955
module Idl::CsrRegisterAccessExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5956
  def csr_name; end
end

# source://idlc//lib/idlc/ast.rb#9538
class Idl::CsrSoftwareWriteAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#9547
  def initialize(input, interval, csr, expression); end

  # source://idlc//lib/idlc/ast.rb#9542
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#9544
  def csr; end

  # source://idlc//lib/idlc/ast.rb#9561
  def csr_known?(symtab); end

  # source://idlc//lib/idlc/ast.rb#9565
  def csr_name; end

  # source://idlc//lib/idlc/ast.rb#9573
  def execute(_symtab); end

  # source://idlc//lib/idlc/ast.rb#9576
  def execute_unknown(_symtab); end

  # source://idlc//lib/idlc/ast.rb#9545
  def expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#82
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#9583
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#9580
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#9551
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#9568
  def value(_symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#9591
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::CsrSoftwareWriteAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#9532
class Idl::CsrSoftwareWriteSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#9533
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#729
class Idl::CsrType < ::Idl::Type
  # source://idlc//lib/idlc/type.rb#736
  sig { params(csr: ::Idl::Csr, qualifiers: T::Array[::Symbol]).void }
  def initialize(csr, qualifiers: T.unsafe(nil)); end

  # source://idlc//lib/idlc/type.rb#733
  sig { returns(::Idl::Csr) }
  def csr; end

  # source://idlc//lib/idlc/type.rb#741
  sig { returns(T::Array[::Idl::CsrField]) }
  def fields; end
end

# source://idlc//lib/idlc/ast.rb#9732
class Idl::CsrWriteAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#9740
  def initialize(input, interval, idx); end

  # source://idlc//lib/idlc/ast.rb#9736
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#9756
  def csr_def(symtab); end

  # source://idlc//lib/idlc/ast.rb#9775
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#9780
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#9738
  def idx; end

  # source://idlc//lib/idlc/ast.rb#9770
  def name(symtab); end

  # source://idlc//lib/idlc/ast.rb#9787
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#9784
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#9766
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#9745
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#9794
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::CsrWriteAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#9728
class Idl::CsrWriteSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#9729
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#828
module Idl::Declaration
  interface!

  # source://idlc//lib/idlc/ast.rb#838
  sig { abstract.params(symtab: ::Idl::SymbolTable).void }
  def add_symbol(symtab); end
end

# source://idlc//lib/idlc/idl_parser.rb#12189
module Idl::Declaration0
  # source://idlc//lib/idlc/idl_parser.rb#12190
  def id; end
end

# source://idlc//lib/idlc/idl_parser.rb#12195
module Idl::Declaration1
  # source://idlc//lib/idlc/idl_parser.rb#12200
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#12204
  def rest; end

  # source://idlc//lib/idlc/idl_parser.rb#12196
  def type_name; end
end

# source://idlc//lib/idlc/ast.rb#6487
class Idl::DontCareLvalueAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#6493
  def initialize(input, interval); end

  # source://idlc//lib/idlc/ast.rb#6491
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6512
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6509
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6501
  def type(_symtab); end

  # source://idlc//lib/idlc/ast.rb#6496
  def type_check(_symtab); end

  # source://idlc//lib/idlc/ast.rb#6506
  def value(_symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6518
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::DontCareLvalueAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6483
class Idl::DontCareLvalueSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6484
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#6424
class Idl::DontCareReturnAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#6430
  def initialize(input, interval); end

  # source://idlc//lib/idlc/ast.rb#6428
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#61
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#6458
  def set_expected_type(t); end

  # source://idlc//lib/idlc/ast.rb#6466
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6463
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6440
  def type(_symtab); end

  # source://idlc//lib/idlc/ast.rb#6435
  def type_check(_symtab); end

  # source://idlc//lib/idlc/ast.rb#6445
  def value(_symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6472
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::DontCareReturnAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6414
class Idl::DontCareReturnSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6415
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#34
Idl::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/ast.rb#8882
class Idl::ElseIfAst < ::Idl::AstNode
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#8896
  def initialize(input, interval, cond, body); end

  # source://idlc//lib/idlc/ast.rb#8894
  sig { returns(::Idl::IfBodyAst) }
  def body; end

  # source://idlc//lib/idlc/ast.rb#8891
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def cond; end

  # source://idlc//lib/idlc/ast.rb#8886
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/prune.rb#343
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#8916
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#8921
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#8932
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#8949
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#8944
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#8900
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#8957
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ElseIfAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1718
class Idl::EnumArrayCastAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#1727
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      enum_class_name: ::Idl::UserTypeNameAst
    ).void
  end
  def initialize(input, interval, enum_class_name); end

  # source://idlc//lib/idlc/ast.rb#1724
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1721
  def enum_class; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#132
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#1752
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1749
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1735
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1731
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1744
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1759
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::EnumArrayCastAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1709
class Idl::EnumArrayCastSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1710
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#1634
class Idl::EnumCastAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#1655
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      user_type_name: ::Idl::UserTypeNameAst,
      expression: T.all(::Idl::AstNode, ::Idl::Rvalue)
    ).void
  end
  def initialize(input, interval, user_type_name, expression); end

  # source://idlc//lib/idlc/ast.rb#1638
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1641
  def enum_name; end

  # source://idlc//lib/idlc/ast.rb#1644
  def expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#107
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#1688
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1685
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1677
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1659
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1682
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1696
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1628
class Idl::EnumCastSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1629
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#433
module Idl::EnumDefinition0
  # source://idlc//lib/idlc/idl_parser.rb#434
  def user_type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#440
module Idl::EnumDefinition1
  # source://idlc//lib/idlc/idl_parser.rb#441
  def int; end
end

# source://idlc//lib/idlc/idl_parser.rb#447
module Idl::EnumDefinition2
  # source://idlc//lib/idlc/idl_parser.rb#452
  def i; end

  # source://idlc//lib/idlc/idl_parser.rb#448
  def user_type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#457
module Idl::EnumDefinition3
  # source://idlc//lib/idlc/idl_parser.rb#462
  def e; end

  # source://idlc//lib/idlc/idl_parser.rb#458
  def user_type_name; end
end

# source://idlc//lib/idlc/type.rb#12
class Idl::EnumDefinitionAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#1819
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      user_type: ::Idl::UserTypeNameAst,
      element_names: T::Array[::Idl::UserTypeNameAst],
      element_values: T::Array[T.nilable(::Idl::IntLiteralAst)]
    ).void
  end
  def initialize(input, interval, user_type, element_names, element_values); end

  # source://idlc//lib/idlc/ast.rb#1868
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#1808
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1843
  sig { returns(T::Array[::String]) }
  def element_names; end

  # source://idlc//lib/idlc/ast.rb#1853
  sig { returns(T::Array[::Integer]) }
  def element_values; end

  # source://idlc//lib/idlc/ast.rb#1884
  def name; end

  # source://idlc//lib/idlc/ast.rb#1898
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1888
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1876
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1856
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1881
  def value(_symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1911
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1771
class Idl::EnumDefinitionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1772
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#1580
class Idl::EnumElementSizeAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#1589
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      enum_class_name: ::Idl::UserTypeNameAst
    ).void
  end
  def initialize(input, interval, enum_class_name); end

  # source://idlc//lib/idlc/ast.rb#1586
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1583
  def enum_class; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#127
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#1609
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1606
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1597
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1593
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1601
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1616
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1571
class Idl::EnumElementSizeSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1572
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#770
module Idl::EnumRef0
  # source://idlc//lib/idlc/idl_parser.rb#771
  def enum_class; end

  # source://idlc//lib/idlc/idl_parser.rb#775
  def member; end
end

# source://idlc//lib/idlc/ast.rb#5858
class Idl::EnumRefAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#5867
  def initialize(input, interval, class_name, member_name); end

  # source://idlc//lib/idlc/ast.rb#5864
  def class_name; end

  # source://idlc//lib/idlc/ast.rb#5862
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#5876
  def freeze_tree(global_symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#117
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#148
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#5865
  def member_name; end

  # source://idlc//lib/idlc/ast.rb#5926
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#5923
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5899
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5889
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#5907
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5934
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::EnumRefAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5847
class Idl::EnumRefSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5848
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#1520
class Idl::EnumSizeAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#1528
  def initialize(input, interval, enum_class_name); end

  # source://idlc//lib/idlc/ast.rb#1526
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1523
  def enum_class; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#122
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#1552
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1549
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1536
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1532
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1544
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1559
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1511
class Idl::EnumSizeSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1512
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#6692
module Idl::EnumToA0
  # source://idlc//lib/idlc/idl_parser.rb#6693
  def user_type_name; end
end

# source://idlc//lib/idlc/type.rb#626
class Idl::EnumerationType < ::Idl::Type
  # source://idlc//lib/idlc/type.rb#656
  sig do
    params(
      type_name: ::String,
      element_names: T::Array[::String],
      element_values: T::Array[::Integer],
      builtin: T::Boolean
    ).void
  end
  def initialize(type_name, element_names, element_values, builtin: T.unsafe(nil)); end

  # source://idlc//lib/idlc/type.rb#671
  sig { returns(T::Boolean) }
  def builtin?; end

  # source://idlc//lib/idlc/type.rb#674
  sig { returns(::Idl::EnumerationType) }
  def clone; end

  # source://idlc//lib/idlc/type.rb#687
  sig { params(element_value: ::Integer).returns(T.nilable(::String)) }
  def element_name(element_value); end

  # source://idlc//lib/idlc/type.rb#635
  sig { returns(T::Array[::String]) }
  def element_names; end

  # source://idlc//lib/idlc/type.rb#639
  sig { returns(T::Array[::Integer]) }
  def element_values; end

  # source://idlc//lib/idlc/type.rb#643
  sig { returns(::Idl::Type) }
  def ref_type; end

  # source://idlc//lib/idlc/type.rb#679
  sig { params(element_name: ::String).returns(T.nilable(::Integer)) }
  def value(element_name); end

  # source://idlc//lib/idlc/type.rb#631
  sig { returns(::Integer) }
  def width; end
end

# source://idlc//lib/idlc/ast.rb#599
module Idl::Executable
  interface!

  # source://idlc//lib/idlc/ast.rb#621
  sig { abstract.params(symtab: ::Idl::SymbolTable).void }
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#625
  sig { abstract.params(symtab: ::Idl::SymbolTable).void }
  def execute_unknown(symtab); end
end

# source://idlc//lib/idlc/ast.rb#628
Idl::ExecutableAst = T.type_alias { T.all(::Idl::AstNode, ::Idl::Executable) }

# source://idlc//lib/idlc/idl_parser.rb#13702
module Idl::ExecuteIfBlock0
  # source://idlc//lib/idlc/idl_parser.rb#13703
  def e; end
end

# source://idlc//lib/idlc/idl_parser.rb#13709
module Idl::ExecuteIfBlock1
  # source://idlc//lib/idlc/idl_parser.rb#13710
  def e; end
end

# source://idlc//lib/idlc/idl_parser.rb#13716
module Idl::ExecuteIfBlock2
  # source://idlc//lib/idlc/idl_parser.rb#13721
  def body; end

  # source://idlc//lib/idlc/idl_parser.rb#13717
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#13727
module Idl::ExecuteIfBlock3
  # source://idlc//lib/idlc/idl_parser.rb#13728
  def e; end
end

# source://idlc//lib/idlc/idl_parser.rb#13734
module Idl::ExecuteIfBlock4
  # source://idlc//lib/idlc/idl_parser.rb#13735
  def body; end
end

# source://idlc//lib/idlc/idl_parser.rb#13741
module Idl::ExecuteIfBlock5
  # source://idlc//lib/idlc/idl_parser.rb#13750
  def elseifs; end

  # source://idlc//lib/idlc/idl_parser.rb#13754
  def final_else; end

  # source://idlc//lib/idlc/idl_parser.rb#13746
  def if_body; end

  # source://idlc//lib/idlc/idl_parser.rb#13742
  def if_cond; end
end

# source://idlc//lib/idlc/ast.rb#920
class Idl::FalseExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#924
  sig { params(input: ::String, interval: T::Range[::Integer]).void }
  def initialize(input, interval); end

  # source://idlc//lib/idlc/ast.rb#929
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#153
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#93
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#944
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#941
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/../../udb/lib/udb/idl/condition_to_udb.rb#71
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#935
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#932
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#938
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::FalseClass) }
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#950
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#916
class Idl::FalseExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#917
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#10826
module Idl::Fetch0
  # source://idlc//lib/idlc/idl_parser.rb#10827
  def function_body; end
end

# source://idlc//lib/idlc/ast.rb#8004
class Idl::FetchAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#8011
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      body: ::Idl::FunctionBodyAst
    ).void
  end
  def initialize(input, interval, body); end

  # source://idlc//lib/idlc/ast.rb#8008
  def body; end

  # source://idlc//lib/idlc/ast.rb#8006
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#8019
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#8033
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#8024
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#8015
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#8040
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::FetchAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#7998
class Idl::FetchSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#7999
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#6096
module Idl::FieldAccessExpression0
  # source://idlc//lib/idlc/idl_parser.rb#6097
  def field_access_eligible_expression; end

  # source://idlc//lib/idlc/idl_parser.rb#6101
  def field_name; end
end

# source://idlc//lib/idlc/ast.rb#5759
class Idl::FieldAccessExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#5769
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      bitfield: T.all(::Idl::AstNode, ::Idl::Rvalue),
      field_name: ::String
    ).void
  end
  def initialize(input, interval, bitfield, field_name); end

  # source://idlc//lib/idlc/ast.rb#5763
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#87
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5775
  def kind(symtab); end

  # source://idlc//lib/idlc/ast.rb#5766
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def obj; end

  # source://idlc//lib/idlc/ast.rb#5826
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#5823
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5780
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5792
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#5810
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5834
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::FieldAccessExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5749
class Idl::FieldAccessExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5750
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#3106
class Idl::FieldAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#3134
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      id: ::Idl::IdAst,
      field_name: ::String,
      rhs: T.all(::Idl::AstNode, ::Idl::Rvalue)
    ).void
  end
  def initialize(input, interval, id, field_name, rhs); end

  # source://idlc//lib/idlc/ast.rb#3119
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#3179
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#3202
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#3116
  sig { returns(::String) }
  def field_name; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#92
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#3110
  sig { returns(::Idl::IdAst) }
  def id; end

  # source://idlc//lib/idlc/ast.rb#3113
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#3212
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#3209
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#3140
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#3154
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#3221
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::FieldAssignmentAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#3094
class Idl::FieldAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3095
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#15831
module Idl::FieldName0; end

# source://idlc//lib/idlc/idl_parser.rb#14342
module Idl::ForLoop0
  # source://idlc//lib/idlc/idl_parser.rb#14343
  def s; end
end

# source://idlc//lib/idlc/idl_parser.rb#14349
module Idl::ForLoop1
  # source://idlc//lib/idlc/idl_parser.rb#14358
  def action; end

  # source://idlc//lib/idlc/idl_parser.rb#14354
  def condition; end

  # source://idlc//lib/idlc/idl_parser.rb#14350
  def for_loop_iteration_variable_declaration; end

  # source://idlc//lib/idlc/idl_parser.rb#14362
  def stmts; end
end

# source://idlc//lib/idlc/ast.rb#8533
class Idl::ForLoopAst < ::Idl::AstNode
  include ::Idl::Executable
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#8558
  def initialize(input, interval, init, condition, update, stmts); end

  # source://idlc//lib/idlc/ast.rb#8549
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def condition; end

  # source://idlc//lib/idlc/ast.rb#8538
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#8676
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#8679
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#202
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#8546
  sig { returns(::Idl::VariableDeclarationWithInitializationAst) }
  def init; end

  # source://idlc//lib/idlc/passes/prune.rb#118
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#197
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#174
  def reachable_functions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#8625
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#8592
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#8631
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#8575
  sig { params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def satisfied?(symtab); end

  # source://idlc//lib/idlc/ast.rb#8556
  sig do
    returns(T::Array[T.any(::Idl::ForLoopAst, ::Idl::IfAst, ::Idl::ImplicationStatementAst, ::Idl::ReturnStatementAst, ::Idl::StatementAst)])
  end
  def stmts; end

  # source://idlc//lib/idlc/ast.rb#8711
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#8701
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/../../udb/lib/udb/idl/condition_to_udb.rb#88
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#8563
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#8552
  sig { returns(T.all(::Idl::AstNode, ::Idl::Executable)) }
  def update; end

  class << self
    # source://idlc//lib/idlc/ast.rb#8721
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ForLoopAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#8554
Idl::ForLoopAst::StmtType = T.type_alias { T.any(::Idl::ForLoopAst, ::Idl::IfAst, ::Idl::ImplicationStatementAst, ::Idl::ReturnStatementAst, ::Idl::StatementAst) }

# source://idlc//lib/idlc/idl_parser.rb#12060
module Idl::ForLoopIterationVariableDeclaration0
  # source://idlc//lib/idlc/idl_parser.rb#12069
  def ary_size; end

  # source://idlc//lib/idlc/idl_parser.rb#12065
  def id; end

  # source://idlc//lib/idlc/idl_parser.rb#12073
  def rval; end

  # source://idlc//lib/idlc/idl_parser.rb#12061
  def type_name; end
end

# source://idlc//lib/idlc/ast.rb#3718
class Idl::ForLoopIterationVariableDeclarationSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3719
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#8521
class Idl::ForLoopSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#8522
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#9416
module Idl::FunctionArgList0
  # source://idlc//lib/idlc/idl_parser.rb#9417
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#9422
module Idl::FunctionArgList1
  # source://idlc//lib/idlc/idl_parser.rb#9423
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#9427
  def rest; end
end

# source://idlc//lib/idlc/idl_parser.rb#16095
module Idl::FunctionBody0
  # source://idlc//lib/idlc/idl_parser.rb#16096
  def choice; end
end

# source://idlc//lib/idlc/idl_parser.rb#16102
module Idl::FunctionBody1
  # source://idlc//lib/idlc/idl_parser.rb#16103
  def func_stmt_list; end
end

# source://idlc//lib/idlc/ast.rb#7859
class Idl::FunctionBodyAst < ::Idl::AstNode
  include ::Idl::Executable
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#7871
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      stmts: T::Array[T.all(::Idl::AstNode, ::Idl::Executable)]
    ).void
  end
  def initialize(input, interval, stmts); end

  # source://idlc//lib/idlc/ast.rb#7864
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#7934
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#7937
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#311
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#22
  def gen_option_adoc; end

  # source://idlc//lib/idlc/passes/find_return_values.rb#67
  def pass_find_return_values(symtab); end

  # source://idlc//lib/idlc/passes/prune.rb#161
  def prune(symtab, args_already_applied: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#7903
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#7918
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#7944
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#7875
  def statements; end

  # source://idlc//lib/idlc/ast.rb#7877
  def stmts; end

  # source://idlc//lib/idlc/ast.rb#7979
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#7974
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#7880
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#7986
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::FunctionBodyAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#7852
class Idl::FunctionBodySyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#7854
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#8869
module Idl::FunctionCall0
  # source://idlc//lib/idlc/idl_parser.rb#8870
  def csr; end

  # source://idlc//lib/idlc/idl_parser.rb#8874
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#8880
module Idl::FunctionCall1
  # source://idlc//lib/idlc/idl_parser.rb#8881
  def csr; end

  # source://idlc//lib/idlc/idl_parser.rb#8889
  def function_arg_list; end

  # source://idlc//lib/idlc/idl_parser.rb#8885
  def function_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#8895
module Idl::FunctionCall2
  # source://idlc//lib/idlc/idl_parser.rb#8896
  def targs; end
end

# source://idlc//lib/idlc/idl_parser.rb#8902
module Idl::FunctionCall3
  # source://idlc//lib/idlc/idl_parser.rb#8911
  def function_arg_list; end

  # source://idlc//lib/idlc/idl_parser.rb#8903
  def function_name; end

  # source://idlc//lib/idlc/idl_parser.rb#8907
  def t; end
end

# source://idlc//lib/idlc/ast.rb#7526
class Idl::FunctionCallExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#7541
  def initialize(input, interval, function_name, targs, args); end

  # source://idlc//lib/idlc/ast.rb#7583
  def arg_nodes; end

  # source://idlc//lib/idlc/ast.rb#7539
  def args; end

  # source://idlc//lib/idlc/ast.rb#7532
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#7739
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#7747
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#7587
  def func_type(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#289
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#28
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#7741
  def name; end

  # source://idlc//lib/idlc/passes/prune.rb#82
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#25
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#21
  def reachable_functions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#7538
  def targs; end

  # source://idlc//lib/idlc/ast.rb#7554
  def template?; end

  # source://idlc//lib/idlc/ast.rb#7559
  def template_arg_nodes; end

  # source://idlc//lib/idlc/ast.rb#7563
  def template_values(symtab, unknown_ok: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#7760
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#7751
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/../../udb/lib/udb/idl/condition_to_udb.rb#163
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#7653
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#7602
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#7662
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#7771
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::FunctionCallExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#7516
class Idl::FunctionCallExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#7517
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#8768
module Idl::FunctionCallTemplateArguments0
  # source://idlc//lib/idlc/idl_parser.rb#8769
  def arg; end
end

# source://idlc//lib/idlc/idl_parser.rb#8774
module Idl::FunctionCallTemplateArguments1
  # source://idlc//lib/idlc/idl_parser.rb#8775
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#8779
  def rest; end
end

# source://idlc//lib/idlc/ast.rb#8072
class Idl::FunctionDefAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#8096
  def initialize(input, interval, name, targs, return_types, arguments, desc, type, body); end

  # source://idlc//lib/idlc/ast.rb#8077
  def <=>(other); end

  # source://idlc//lib/idlc/ast.rb#8364
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#8326
  def apply_template_and_arg_syms(symtab); end

  # source://idlc//lib/idlc/ast.rb#8117
  def argument_nodes; end

  # source://idlc//lib/idlc/ast.rb#8147
  def arguments(symtab); end

  # source://idlc//lib/idlc/ast.rb#8178
  def arguments_list_str; end

  # source://idlc//lib/idlc/ast.rb#8416
  def body; end

  # source://idlc//lib/idlc/ast.rb#8422
  def builtin?; end

  # source://idlc//lib/idlc/ast.rb#8258
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#8132
  def description; end

  # source://idlc//lib/idlc/ast.rb#8083
  def eql?(other); end

  # source://idlc//lib/idlc/ast.rb#8430
  def external?; end

  # source://idlc//lib/idlc/ast.rb#8120
  def freeze_tree(global_symtab); end

  # source://idlc//lib/idlc/ast.rb#8426
  def generated?; end

  # source://idlc//lib/idlc/ast.rb#8287
  def name; end

  # source://idlc//lib/idlc/ast.rb#8142
  def num_args; end

  # source://idlc//lib/idlc/passes/prune.rb#141
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#8434
  def qualifier_str; end

  # source://idlc//lib/idlc/ast.rb#8117
  def reachable_functions_cache; end

  # source://idlc//lib/idlc/ast.rb#8183
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#8246
  def return_type_list_str; end

  # source://idlc//lib/idlc/ast.rb#8075
  def return_type_nodes; end

  # source://idlc//lib/idlc/ast.rb#8378
  def template_names; end

  # source://idlc//lib/idlc/ast.rb#8384
  def template_types(symtab); end

  # source://idlc//lib/idlc/ast.rb#8137
  def templated?; end

  # source://idlc//lib/idlc/ast.rb#8490
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#8447
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#8337
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#8406
  def type_check_args(symtab); end

  # source://idlc//lib/idlc/ast.rb#8410
  def type_check_body(symtab); end

  # source://idlc//lib/idlc/ast.rb#8310
  def type_check_from_call(symtab); end

  # source://idlc//lib/idlc/ast.rb#8402
  def type_check_return(symtab); end

  # source://idlc//lib/idlc/ast.rb#8397
  def type_check_targs(symtab); end

  # source://idlc//lib/idlc/ast.rb#8292
  def type_check_template_instance(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#8503
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::FunctionDefAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#8052
class Idl::FunctionDefSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#8053
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#13044
module Idl::FunctionIfBlock0
  # source://idlc//lib/idlc/idl_parser.rb#13045
  def e; end
end

# source://idlc//lib/idlc/idl_parser.rb#13051
module Idl::FunctionIfBlock1
  # source://idlc//lib/idlc/idl_parser.rb#13052
  def e; end
end

# source://idlc//lib/idlc/idl_parser.rb#13058
module Idl::FunctionIfBlock2
  # source://idlc//lib/idlc/idl_parser.rb#13063
  def body; end

  # source://idlc//lib/idlc/idl_parser.rb#13059
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#13069
module Idl::FunctionIfBlock3
  # source://idlc//lib/idlc/idl_parser.rb#13070
  def e; end
end

# source://idlc//lib/idlc/idl_parser.rb#13076
module Idl::FunctionIfBlock4
  # source://idlc//lib/idlc/idl_parser.rb#13077
  def body; end
end

# source://idlc//lib/idlc/idl_parser.rb#13083
module Idl::FunctionIfBlock5
  # source://idlc//lib/idlc/idl_parser.rb#13092
  def elseifs; end

  # source://idlc//lib/idlc/idl_parser.rb#13096
  def final_else; end

  # source://idlc//lib/idlc/idl_parser.rb#13088
  def if_body; end

  # source://idlc//lib/idlc/idl_parser.rb#13084
  def if_cond; end
end

# source://idlc//lib/idlc/idl_parser.rb#9334
module Idl::FunctionName0; end

# source://idlc//lib/idlc/type.rb#748
class Idl::FunctionType < ::Idl::Type
  # source://idlc//lib/idlc/type.rb#751
  def initialize(func_name, func_def_ast, symtab); end

  # source://idlc//lib/idlc/type.rb#830
  sig do
    params(
      symtab: ::Idl::SymbolTable,
      argument_nodes: T::Array[::Idl::Rvalue],
      call_site_symtab: ::Idl::SymbolTable,
      func_call_ast: ::Idl::FunctionCallExpressionAst
    ).returns(T::Array[T.any(::Integer, ::Symbol)])
  end
  def apply_arguments(symtab, argument_nodes, call_site_symtab, func_call_ast); end

  # source://idlc//lib/idlc/type.rb#801
  def apply_template_values(template_values, func_call_ast); end

  # source://idlc//lib/idlc/type.rb#934
  def argument_name(index, template_values = T.unsafe(nil), func_call_ast); end

  # source://idlc//lib/idlc/type.rb#919
  def argument_type(index, template_values, argument_nodes, call_site_symtab, func_call_ast); end

  # source://idlc//lib/idlc/type.rb#851
  def argument_values(symtab, argument_nodes, call_site_symtab, func_call_ast); end

  # source://idlc//lib/idlc/type.rb#949
  def body; end

  # source://idlc//lib/idlc/type.rb#763
  def builtin?; end

  # source://idlc//lib/idlc/type.rb#759
  def clone; end

  # source://idlc//lib/idlc/type.rb#767
  def external?; end

  # source://idlc//lib/idlc/type.rb#749
  def func_def_ast; end

  # source://idlc//lib/idlc/type.rb#765
  def generated?; end

  # source://idlc//lib/idlc/type.rb#769
  def num_args; end

  # source://idlc//lib/idlc/type.rb#877
  sig do
    params(
      template_values: T::Array[::Integer],
      argument_nodes: T::Array[::Idl::Rvalue],
      func_call_ast: ::Idl::FunctionCallExpressionAst
    ).returns(::Idl::Type)
  end
  def return_type(template_values, argument_nodes, func_call_ast); end

  # source://idlc//lib/idlc/type.rb#906
  def return_types(template_values, argument_nodes, call_site_symtab, func_call_ast); end

  # source://idlc//lib/idlc/type.rb#890
  def return_value(template_values, argument_nodes, call_site_symtab, func_call_ast); end

  # source://idlc//lib/idlc/type.rb#795
  def template_names; end

  # source://idlc//lib/idlc/type.rb#797
  def template_types(symtab); end

  # source://idlc//lib/idlc/type.rb#799
  def templated?; end

  # source://idlc//lib/idlc/type.rb#771
  def type_check_call(template_values, argument_nodes, call_site_symtab, func_call_ast); end
end

# source://idlc//lib/idlc/ast.rb#1186
class Idl::GlobalAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#1201
  def initialize(input, interval, declaration); end

  # source://idlc//lib/idlc/ast.rb#1214
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#1190
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1197
  def declaration; end

  # source://idlc//lib/idlc/ast.rb#1192
  def id; end

  # source://idlc//lib/idlc/ast.rb#1224
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1221
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1210
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1206
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1231
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/idl_parser.rb#269
module Idl::GlobalDefinition0; end

# source://idlc//lib/idlc/idl_parser.rb#272
module Idl::GlobalDefinition1
  # source://idlc//lib/idlc/idl_parser.rb#273
  def const; end

  # source://idlc//lib/idlc/idl_parser.rb#277
  def single_declaration_with_initialization; end
end

# source://idlc//lib/idlc/idl_parser.rb#283
module Idl::GlobalDefinition2
  # source://idlc//lib/idlc/idl_parser.rb#284
  def declaration; end
end

# source://idlc//lib/idlc/ast.rb#1180
class Idl::GlobalSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1181
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#1106
class Idl::GlobalWithInitializationAst < ::Idl::AstNode
  include ::Idl::Executable
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#1121
  def initialize(input, interval, var_decl_with_init); end

  # source://idlc//lib/idlc/ast.rb#1148
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#1114
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1142
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#1145
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#1110
  def id; end

  # source://idlc//lib/idlc/ast.rb#1111
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#1162
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1157
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1132
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#1127
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1137
  def value(symtab); end

  # source://idlc//lib/idlc/ast.rb#1117
  def var_decl_with_init; end

  class << self
    # source://idlc//lib/idlc/ast.rb#1169
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1091
class Idl::GlobalWithInitializationSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1092
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#16283
module Idl::Id0; end

# source://idlc//lib/idlc/ast.rb#968
class Idl::IdAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#982
  sig { params(input: ::String, interval: T::Range[::Integer], name: ::String).void }
  def initialize(input, interval, name); end

  # source://idlc//lib/idlc/ast.rb#1013
  sig { returns(T::Boolean) }
  def const?; end

  # source://idlc//lib/idlc/ast.rb#972
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#158
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#97
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#1029
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(::Integer, ::Symbol)) }
  def max_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#1047
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(::Integer, ::Symbol)) }
  def min_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#976
  sig { returns(::String) }
  def name; end

  # source://idlc//lib/idlc/ast.rb#979
  sig { override.returns(::String) }
  def text_value; end

  # source://idlc//lib/idlc/ast.rb#1069
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1066
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/../../udb/lib/udb/idl/condition_to_udb.rb#76
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#995
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#989
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#1016
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1076
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#961
class Idl::IdSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#962
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#9005
class Idl::IfAst < ::Idl::AstNode
  include ::Idl::Executable
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#9029
  def initialize(input, interval, if_cond, if_body, elseifs, final_else_body); end

  # source://idlc//lib/idlc/ast.rb#9010
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#9024
  sig { returns(T::Array[::Idl::ElseIfAst]) }
  def elseifs; end

  # source://idlc//lib/idlc/ast.rb#9198
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#9244
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#9027
  sig { returns(::Idl::IfBodyAst) }
  def final_else_body; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#331
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#34
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#9021
  sig { returns(::Idl::IfBodyAst) }
  def if_body; end

  # source://idlc//lib/idlc/ast.rb#9018
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def if_cond; end

  # source://idlc//lib/idlc/passes/find_return_values.rb#35
  def pass_find_return_values(values, current_conditions, symtab); end

  # source://idlc//lib/idlc/passes/prune.rb#355
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#101
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#84
  def reachable_functions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#9091
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#9100
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#9141
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#9078
  def taken_body(symtab); end

  # source://idlc//lib/idlc/ast.rb#9267
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#9251
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#9040
  def type_check(symtab); end

  private

  # source://idlc//lib/idlc/ast.rb#9159
  def execute_after_if(symtab); end

  # source://idlc//lib/idlc/ast.rb#9235
  def execute_unknown_after_if(symtab); end

  # source://idlc//lib/idlc/ast.rb#9109
  def return_values_after_if(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#9277
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::IfAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#8736
class Idl::IfBodyAst < ::Idl::AstNode
  include ::Idl::Executable
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#8747
  def initialize(input, interval, body_stmts); end

  # source://idlc//lib/idlc/ast.rb#8741
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#8824
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#8850
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#35
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#71
  def gen_option_adoc; end

  # source://idlc//lib/idlc/passes/prune.rb#331
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#8769
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#8775
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#8796
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#8745
  def stmts; end

  # source://idlc//lib/idlc/ast.rb#8863
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#8858
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#8756
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#8870
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::IfBodyAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#8970
class Idl::IfSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#8971
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#8010
module Idl::ImplicationExpression0
  # source://idlc//lib/idlc/idl_parser.rb#8011
  def antecedent; end

  # source://idlc//lib/idlc/idl_parser.rb#8015
  def consequent; end
end

# source://idlc//lib/idlc/idl_parser.rb#8021
module Idl::ImplicationExpression1
  # source://idlc//lib/idlc/idl_parser.rb#8022
  def antecedent; end

  # source://idlc//lib/idlc/idl_parser.rb#8026
  def consequent; end
end

# source://idlc//lib/idlc/ast.rb#3989
class Idl::ImplicationExpressionAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#3998
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      antecedent: T.all(::Idl::AstNode, ::Idl::Rvalue),
      consequent: T.all(::Idl::AstNode, ::Idl::Rvalue)
    ).void
  end
  def initialize(input, interval, antecedent, consequent); end

  # source://idlc//lib/idlc/ast.rb#4009
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def antecedent; end

  # source://idlc//lib/idlc/ast.rb#4012
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def consequent; end

  # source://idlc//lib/idlc/ast.rb#4004
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4021
  sig { params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def satisfied?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4030
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#4027
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/../../udb/lib/udb/idl/condition_to_udb.rb#25
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#4015
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#4038
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ImplicationExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#3978
class Idl::ImplicationExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3980
  sig { override.returns(::Idl::ImplicationExpressionAst) }
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#8222
module Idl::ImplicationForLoop0
  # source://idlc//lib/idlc/idl_parser.rb#8223
  def s; end
end

# source://idlc//lib/idlc/idl_parser.rb#8229
module Idl::ImplicationForLoop1
  # source://idlc//lib/idlc/idl_parser.rb#8238
  def action; end

  # source://idlc//lib/idlc/idl_parser.rb#8234
  def condition; end

  # source://idlc//lib/idlc/idl_parser.rb#8230
  def for_loop_iteration_variable_declaration; end

  # source://idlc//lib/idlc/idl_parser.rb#8242
  def stmts; end
end

# source://idlc//lib/idlc/idl_parser.rb#8544
module Idl::ImplicationStatement0
  # source://idlc//lib/idlc/idl_parser.rb#8545
  def implication_expression; end
end

# source://idlc//lib/idlc/ast.rb#4058
class Idl::ImplicationStatementAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#4066
  sig do
    params(
      input: ::String,
      interval: T::Range[::Integer],
      implication_expression: ::Idl::ImplicationExpressionAst
    ).void
  end
  def initialize(input, interval, implication_expression); end

  # source://idlc//lib/idlc/ast.rb#4071
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4074
  sig { returns(::Idl::ImplicationExpressionAst) }
  def expression; end

  # source://idlc//lib/idlc/ast.rb#4082
  sig { params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def satisfied?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4090
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#4087
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/../../udb/lib/udb/idl/condition_to_udb.rb#46
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#4077
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#4097
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ImplicationExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#4051
class Idl::ImplicationStatementSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4053
  sig { override.returns(::Idl::ImplicationStatementAst) }
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#189
module Idl::IncludeStatement0
  # source://idlc//lib/idlc/idl_parser.rb#190
  def string; end
end

# source://idlc//lib/idlc/ast.rb#849
class Idl::IncludeStatementAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#858
  sig { params(input: ::String, interval: T::Range[T.untyped], filename: ::Idl::AstNode).void }
  def initialize(input, interval, filename); end

  # source://idlc//lib/idlc/ast.rb#851
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#855
  sig { returns(::String) }
  def filename; end

  # source://idlc//lib/idlc/ast.rb#863
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#866
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end
end

# source://idlc//lib/idlc/ast.rb#841
class Idl::IncludeStatementSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#843
  sig { override.returns(::Idl::IncludeStatementAst) }
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#16179
module Idl::InstructionOperation0
  # source://idlc//lib/idlc/idl_parser.rb#16180
  def choice; end
end

# source://idlc//lib/idlc/idl_parser.rb#16186
module Idl::InstructionOperation1
  # source://idlc//lib/idlc/idl_parser.rb#16187
  def op_stmt_list; end
end

# source://idlc//lib/idlc/ast.rb#7846
class Idl::InstructionOperationSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#7847
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#1478
module Idl::Int0; end

# source://idlc//lib/idlc/idl_parser.rb#1481
module Idl::Int1; end

# source://idlc//lib/idlc/idl_parser.rb#1508
module Idl::Int10; end

# source://idlc//lib/idlc/idl_parser.rb#1511
module Idl::Int11; end

# source://idlc//lib/idlc/idl_parser.rb#1514
module Idl::Int12; end

# source://idlc//lib/idlc/idl_parser.rb#1517
module Idl::Int13; end

# source://idlc//lib/idlc/idl_parser.rb#1520
module Idl::Int14; end

# source://idlc//lib/idlc/idl_parser.rb#1523
module Idl::Int15; end

# source://idlc//lib/idlc/idl_parser.rb#1526
module Idl::Int16; end

# source://idlc//lib/idlc/idl_parser.rb#1484
module Idl::Int2; end

# source://idlc//lib/idlc/idl_parser.rb#1487
module Idl::Int3; end

# source://idlc//lib/idlc/idl_parser.rb#1490
module Idl::Int4; end

# source://idlc//lib/idlc/idl_parser.rb#1493
module Idl::Int5; end

# source://idlc//lib/idlc/idl_parser.rb#1496
module Idl::Int6; end

# source://idlc//lib/idlc/idl_parser.rb#1499
module Idl::Int7; end

# source://idlc//lib/idlc/idl_parser.rb#1502
module Idl::Int8; end

# source://idlc//lib/idlc/idl_parser.rb#1505
module Idl::Int9; end

# source://idlc//lib/idlc/ast.rb#7172
class Idl::IntLiteralAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#7179
  sig { params(input: T.nilable(::String), interval: T.nilable(T::Range[::Integer]), text: ::String).void }
  def initialize(input, interval, text); end

  # source://idlc//lib/idlc/ast.rb#7176
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#7186
  def freeze_tree(global_symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#142
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#103
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#7443
  sig { returns(::Integer) }
  def radix; end

  # source://idlc//lib/idlc/ast.rb#7426
  sig { returns(T::Boolean) }
  def signed?; end

  # source://idlc//lib/idlc/ast.rb#7184
  def text_value; end

  # source://idlc//lib/idlc/ast.rb#7481
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#7414
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#7417
  sig { override.returns(::String) }
  def to_idl_verbose; end

  # source://idlc//lib/idlc/ast.rb#7212
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#7196
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#7333
  def unsigned_value; end

  # source://idlc//lib/idlc/ast.rb#7286
  def value(symtab); end

  # source://idlc//lib/idlc/ast.rb#7247
  def width(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#7504
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::IntLiteralAst)
    end
    def from_h(yaml, source_mapper); end

    # source://idlc//lib/idlc/ast.rb#7492
    def radix_to_verilog(r); end
  end
end

# source://idlc//lib/idlc/ast.rb#7076
module Idl::IntLiteralSyntaxNode
  # source://idlc//lib/idlc/ast.rb#7077
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#16
module Idl::Isa0
  # source://idlc//lib/idlc/idl_parser.rb#21
  def definitions; end

  # source://idlc//lib/idlc/idl_parser.rb#17
  def version_string; end
end

# source://idlc//lib/idlc/ast.rb#1257
class Idl::IsaAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#1284
  def add_global_symbols(symtab); end

  # source://idlc//lib/idlc/ast.rb#1270
  def bitfields; end

  # source://idlc//lib/idlc/ast.rb#1261
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#1258
  def definitions; end

  # source://idlc//lib/idlc/ast.rb#1267
  def enums; end

  # source://idlc//lib/idlc/ast.rb#1279
  def fetch; end

  # source://idlc//lib/idlc/ast.rb#1276
  def functions; end

  # source://idlc//lib/idlc/ast.rb#1264
  def globals; end

  # source://idlc//lib/idlc/ast.rb#1299
  def replace_include!(include_ast, isa_ast); end

  # source://idlc//lib/idlc/ast.rb#1273
  def structs; end

  # source://idlc//lib/idlc/ast.rb#1332
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#1318
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#1309
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#1339
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#1244
class Idl::IsaSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#1245
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#15040
module Idl::Keyword0; end

# source://idlc//lib/idlc/idl_parser.rb#15043
module Idl::Keyword1; end

# source://idlc//lib/idlc/idl_parser.rb#15070
module Idl::Keyword10; end

# source://idlc//lib/idlc/idl_parser.rb#15073
module Idl::Keyword11; end

# source://idlc//lib/idlc/idl_parser.rb#15076
module Idl::Keyword12; end

# source://idlc//lib/idlc/idl_parser.rb#15079
module Idl::Keyword13; end

# source://idlc//lib/idlc/idl_parser.rb#15082
module Idl::Keyword14; end

# source://idlc//lib/idlc/idl_parser.rb#15085
module Idl::Keyword15; end

# source://idlc//lib/idlc/idl_parser.rb#15046
module Idl::Keyword2; end

# source://idlc//lib/idlc/idl_parser.rb#15049
module Idl::Keyword3; end

# source://idlc//lib/idlc/idl_parser.rb#15052
module Idl::Keyword4; end

# source://idlc//lib/idlc/idl_parser.rb#15055
module Idl::Keyword5; end

# source://idlc//lib/idlc/idl_parser.rb#15058
module Idl::Keyword6; end

# source://idlc//lib/idlc/idl_parser.rb#15061
module Idl::Keyword7; end

# source://idlc//lib/idlc/idl_parser.rb#15064
module Idl::Keyword8; end

# source://idlc//lib/idlc/idl_parser.rb#15067
module Idl::Keyword9; end

# source://idlc//lib/idlc/ast.rb#3325
class Idl::MultiVariableAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#3347
  def initialize(input, interval, variables, function_call); end

  # source://idlc//lib/idlc/ast.rb#3329
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#3392
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#3416
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/ast.rb#3345
  def function_call; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#71
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#3356
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#3427
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#3424
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#3361
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#3344
  def variables; end

  # source://idlc//lib/idlc/ast.rb#3352
  def vars; end

  class << self
    # source://idlc//lib/idlc/ast.rb#3435
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::MultiVariableAssignmentAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#3315
class Idl::MultiVariableAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3316
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#3459
class Idl::MultiVariableDeclarationAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#3475
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      type_name: T.any(::Idl::BuiltinTypeNameAst, ::Idl::UserTypeNameAst),
      var_names: T::Array[::Idl::IdAst]
    ).void
  end
  def initialize(input, interval, type_name, var_names); end

  # source://idlc//lib/idlc/ast.rb#3508
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#3463
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#180
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#3482
  def make_global; end

  # source://idlc//lib/idlc/ast.rb#3519
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#3516
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#3499
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#3492
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#3469
  def type_name; end

  # source://idlc//lib/idlc/ast.rb#3472
  def var_name_nodes; end

  # source://idlc//lib/idlc/ast.rb#3487
  def var_names; end

  class << self
    # source://idlc//lib/idlc/ast.rb#3527
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::MultiVariableDeclarationAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#3448
class Idl::MultiVariableDeclarationSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3449
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#6233
class Idl::NoopAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#6237
  def initialize; end

  # source://idlc//lib/idlc/ast.rb#6235
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6245
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#6248
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#17
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#6255
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6252
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6242
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6261
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::NoopAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/idl_parser.rb#3497
module Idl::P0BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#3498
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#3502
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3507
module Idl::P0BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#3508
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#3512
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3615
module Idl::P1BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#3616
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#3620
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3625
module Idl::P1BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#3626
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#3630
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3733
module Idl::P2BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#3734
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#3738
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3743
module Idl::P2BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#3744
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#3748
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3851
module Idl::P3BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#3852
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#3856
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3861
module Idl::P3BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#3862
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#3866
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4087
module Idl::P4BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#4088
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#4092
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4097
module Idl::P4BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#4098
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#4102
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4323
module Idl::P5BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#4324
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#4328
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4333
module Idl::P5BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#4334
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#4338
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3257
module Idl::P5BinaryOperator0; end

# source://idlc//lib/idlc/idl_parser.rb#4559
module Idl::P6BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#4560
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#4564
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4569
module Idl::P6BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#4570
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#4574
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4795
module Idl::P7BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#4796
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#4800
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4805
module Idl::P7BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#4806
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#4810
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3337
module Idl::P7BinaryOperator0; end

# source://idlc//lib/idlc/idl_parser.rb#5031
module Idl::P8BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5032
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#5036
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#5041
module Idl::P8BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#5042
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#5046
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#5267
module Idl::P9BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5268
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#5272
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#5277
module Idl::P9BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#5278
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#5282
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#5503
module Idl::ParenExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5504
  def e; end
end

# source://idlc//lib/idlc/ast.rb#5223
class Idl::ParenExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#5229
  def initialize(input, interval, exp); end

  # source://idlc//lib/idlc/ast.rb#5227
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#5231
  def expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#137
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5233
  def invert(symtab); end

  # source://idlc//lib/idlc/ast.rb#5249
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#5246
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/../../udb/lib/udb/idl/condition_to_udb.rb#39
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#5239
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5236
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#5242
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5256
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ParenExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5213
class Idl::ParenExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5214
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#2620
class Idl::PcAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#2631
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      rval: T.all(::Idl::AstNode, ::Idl::Rvalue)
    ).void
  end
  def initialize(input, interval, rval); end

  # source://idlc//lib/idlc/ast.rb#2624
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#2637
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#2641
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#247
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2628
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#2654
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#2651
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2645
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#2661
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::PcAssignmentAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#2614
class Idl::PcAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2615
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#6455
module Idl::PostDec0
  # source://idlc//lib/idlc/idl_parser.rb#6456
  def rval; end
end

# source://idlc//lib/idlc/ast.rb#5521
class Idl::PostDecrementExpressionAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#5530
  def initialize(input, interval, rval); end

  # source://idlc//lib/idlc/ast.rb#5525
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#5547
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#5563
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#50
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5528
  sig { returns(T.any(::Idl::BuiltinVariableAst, ::Idl::IdAst, ::Idl::IntLiteralAst, ::Idl::StringLiteralAst)) }
  def rval; end

  # source://idlc//lib/idlc/ast.rb#5571
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#5568
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5542
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5534
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5578
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::PostDecrementExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5511
class Idl::PostDecrementExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5512
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#6512
module Idl::PostInc0
  # source://idlc//lib/idlc/idl_parser.rb#6513
  def rval; end
end

# source://idlc//lib/idlc/ast.rb#5676
class Idl::PostIncrementExpressionAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#5684
  def initialize(input, interval, rval); end

  # source://idlc//lib/idlc/ast.rb#5680
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#5704
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#5721
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#45
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5682
  def rval; end

  # source://idlc//lib/idlc/ast.rb#5730
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#5727
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5699
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5689
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5737
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::PostIncrementExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5666
class Idl::PostIncrementExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5667
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#5583
module Idl::ReplicationExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5584
  def n; end

  # source://idlc//lib/idlc/idl_parser.rb#5588
  def v; end
end

# source://idlc//lib/idlc/ast.rb#5439
class Idl::ReplicationExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#5449
  def initialize(input, interval, n, v); end

  # source://idlc//lib/idlc/ast.rb#5443
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#277
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5446
  def n; end

  # source://idlc//lib/idlc/ast.rb#5490
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#5487
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#5475
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#5454
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#5447
  def v; end

  # source://idlc//lib/idlc/ast.rb#5466
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#5498
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ReplicationExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5429
class Idl::ReplicationExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5430
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#12698
module Idl::ReturnExpression0
  # source://idlc//lib/idlc/idl_parser.rb#12699
  def e; end
end

# source://idlc//lib/idlc/idl_parser.rb#12704
module Idl::ReturnExpression1
  # source://idlc//lib/idlc/idl_parser.rb#12705
  def e; end
end

# source://idlc//lib/idlc/idl_parser.rb#12710
module Idl::ReturnExpression2
  # source://idlc//lib/idlc/idl_parser.rb#12711
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#12715
  def rest; end
end

# source://idlc//lib/idlc/idl_parser.rb#12720
module Idl::ReturnExpression3
  # source://idlc//lib/idlc/idl_parser.rb#12721
  def vals; end
end

# source://idlc//lib/idlc/ast.rb#6629
class Idl::ReturnExpressionAst < ::Idl::AstNode
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#6637
  def initialize(input, interval, return_nodes); end

  # source://idlc//lib/idlc/ast.rb#6633
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6681
  def enclosing_function; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#30
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#115
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#6654
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#6643
  def return_types(symtab); end

  # source://idlc//lib/idlc/ast.rb#6686
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#6635
  def return_value_nodes; end

  # source://idlc//lib/idlc/ast.rb#6697
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#6711
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6708
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6666
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6718
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ReturnExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6616
class Idl::ReturnExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6617
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#12890
module Idl::ReturnStatement0
  # source://idlc//lib/idlc/idl_parser.rb#12895
  def expression; end

  # source://idlc//lib/idlc/idl_parser.rb#12891
  def return_expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#12901
module Idl::ReturnStatement1
  # source://idlc//lib/idlc/idl_parser.rb#12902
  def return_expression; end
end

# source://idlc//lib/idlc/ast.rb#6540
class Idl::ReturnStatementAst < ::Idl::AstNode
  include ::Idl::Returns

  # source://idlc//lib/idlc/ast.rb#6550
  def initialize(input, interval, return_expression); end

  # source://idlc//lib/idlc/ast.rb#6544
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6579
  def enclosing_function; end

  # source://idlc//lib/idlc/ast.rb#6565
  def expected_return_type(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#271
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#77
  def gen_option_adoc; end

  # source://idlc//lib/idlc/passes/find_return_values.rb#19
  def pass_find_return_values(values, current_conditions, symtab); end

  # source://idlc//lib/idlc/ast.rb#6546
  def return_expression; end

  # source://idlc//lib/idlc/ast.rb#6560
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#6555
  def return_types(symtab); end

  # source://idlc//lib/idlc/ast.rb#6584
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#6575
  def return_value_nodes; end

  # source://idlc//lib/idlc/ast.rb#6589
  def return_values(symtab); end

  # source://idlc//lib/idlc/ast.rb#6597
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6594
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6570
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6604
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::ReturnStatementAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6529
class Idl::ReturnStatementSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6530
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#631
module Idl::Returns
  abstract!

  # source://idlc//lib/idlc/ast.rb#672
  sig { params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def expected_return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#649
  sig { abstract.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def return_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#654
  sig do
    abstract
      .params(
        symtab: ::Idl::SymbolTable
      ).returns(T.nilable(T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)])))
  end
  def return_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#668
  sig do
    abstract
      .params(
        symtab: ::Idl::SymbolTable
      ).returns(T::Array[T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)])])
  end
  def return_values(symtab); end
end

# source://idlc//lib/idlc/interfaces.rb#13
module Idl::RuntimeParam
  include ::Kernel

  interface!

  # source://idlc//lib/idlc/interfaces.rb#39
  sig { abstract.returns(T::Array[::Idl::Schema]) }
  def all_schemas; end

  # source://idlc//lib/idlc/interfaces.rb#27
  sig { abstract.returns(::String) }
  def description; end

  # source://idlc//lib/idlc/interfaces.rb#48
  sig { abstract.returns(::Idl::Type) }
  def idl_type; end

  # source://idlc//lib/idlc/interfaces.rb#24
  sig { abstract.returns(::String) }
  def name; end

  # source://idlc//lib/idlc/interfaces.rb#36
  sig { abstract.returns(T::Array[::Idl::Schema]) }
  def possible_schemas; end

  # source://idlc//lib/idlc/interfaces.rb#33
  sig { abstract.returns(::Idl::Schema) }
  def schema; end

  # source://idlc//lib/idlc/interfaces.rb#30
  sig { abstract.returns(T::Boolean) }
  def schema_known?; end

  # source://idlc//lib/idlc/interfaces.rb#45
  sig do
    abstract
      .returns(T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean))
  end
  def value; end

  # source://idlc//lib/idlc/interfaces.rb#42
  sig { abstract.returns(T::Boolean) }
  def value_known?; end
end

# source://idlc//lib/idlc/interfaces.rb#20
Idl::RuntimeParam::ValueType = T.type_alias { T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean) }

# source://idlc//lib/idlc/ast.rb#723
module Idl::Rvalue
  abstract!

  # source://idlc//lib/idlc/ast.rb#773
  sig { params(symtab: ::Idl::SymbolTable).returns(T.any(::Integer, ::Symbol)) }
  def max_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#783
  sig { params(symtab: ::Idl::SymbolTable).returns(T.any(::Integer, ::Symbol)) }
  def min_value(symtab); end

  # source://idlc//lib/idlc/ast.rb#808
  sig { params(value: ::Integer, width: ::Integer, signed: T::Boolean).returns(::Integer) }
  def truncate(value, width, signed); end

  # source://idlc//lib/idlc/ast.rb#746
  sig { abstract.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#770
  sig do
    abstract
      .params(
        symtab: ::Idl::SymbolTable
      ).returns(T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)]))
  end
  def value(symtab); end

  # source://idlc//lib/idlc/ast.rb#805
  sig do
    params(
      symtab: ::Idl::SymbolTable
    ).returns(T::Array[T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)])])
  end
  def values(symtab); end
end

# source://idlc//lib/idlc/ast.rb#825
Idl::RvalueAst = T.type_alias { T.all(::Idl::AstNode, ::Idl::Rvalue) }

# source://idlc//lib/idlc/interfaces.rb#52
module Idl::Schema
  interface!

  # source://idlc//lib/idlc/interfaces.rb#61
  sig { abstract.returns(::Integer) }
  def max_val; end

  # source://idlc//lib/idlc/interfaces.rb#58
  sig { abstract.returns(T::Boolean) }
  def max_val_known?; end

  # source://idlc//lib/idlc/interfaces.rb#67
  sig { abstract.returns(::Integer) }
  def min_val; end

  # source://idlc//lib/idlc/interfaces.rb#64
  sig { abstract.returns(T::Boolean) }
  def min_val_known?; end

  # source://idlc//lib/idlc/interfaces.rb#70
  sig { abstract.returns(::Idl::Type) }
  def to_idl_type; end
end

# source://idlc//lib/idlc/ast.rb#4251
class Idl::SignCastAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#4259
  def initialize(input, interval, exp); end

  # source://idlc//lib/idlc/ast.rb#4255
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4257
  def expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#163
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#4288
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#4285
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#4267
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#4262
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#4270
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#4295
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::SignCastAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#4245
class Idl::SignCastSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4246
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#12362
module Idl::SingleDeclaration0
  # source://idlc//lib/idlc/idl_parser.rb#12363
  def ary_size_decl; end
end

# source://idlc//lib/idlc/idl_parser.rb#12368
module Idl::SingleDeclaration1
  # source://idlc//lib/idlc/idl_parser.rb#12377
  def ary_size; end

  # source://idlc//lib/idlc/idl_parser.rb#12373
  def id; end

  # source://idlc//lib/idlc/idl_parser.rb#12369
  def type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#11931
module Idl::SingleDeclarationWithInitialization0
  # source://idlc//lib/idlc/idl_parser.rb#11940
  def ary_size; end

  # source://idlc//lib/idlc/idl_parser.rb#11936
  def id; end

  # source://idlc//lib/idlc/idl_parser.rb#11944
  def rval; end

  # source://idlc//lib/idlc/idl_parser.rb#11932
  def type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#16722
module Idl::Space0
  # source://idlc//lib/idlc/idl_parser.rb#16723
  def space?; end
end

# source://idlc//lib/idlc/idl_parser.rb#12462
module Idl::Statement0
  # source://idlc//lib/idlc/idl_parser.rb#12463
  def a; end

  # source://idlc//lib/idlc/idl_parser.rb#12467
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#12473
module Idl::Statement1
  # source://idlc//lib/idlc/idl_parser.rb#12474
  def a; end
end

# source://idlc//lib/idlc/ast.rb#6274
class Idl::StatementAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#6282
  def initialize(input, interval, action); end

  # source://idlc//lib/idlc/ast.rb#6280
  def action; end

  # source://idlc//lib/idlc/ast.rb#6278
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6292
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#6302
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#259
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#83
  def gen_option_adoc; end

  # source://idlc//lib/idlc/passes/prune.rb#222
  def prune(symtab); end

  # source://idlc//lib/idlc/passes/reachable_exceptions.rb#82
  def reachable_exceptions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/reachable_functions.rb#69
  def reachable_functions(symtab, cache = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#6316
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6313
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6287
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6323
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::StatementAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6227
class Idl::StatementSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6228
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#16625
module Idl::String0; end

# source://idlc//lib/idlc/idl_parser.rb#16628
module Idl::String1; end

# source://idlc//lib/idlc/ast.rb#7026
class Idl::StringLiteralAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#7033
  sig { params(input: T.nilable(::String), interval: T.nilable(T::Range[::Integer]), text: ::String).void }
  def initialize(input, interval, text); end

  # source://idlc//lib/idlc/ast.rb#7030
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#55
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#7040
  sig { override.returns(::String) }
  def text_value; end

  # source://idlc//lib/idlc/ast.rb#7058
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#7055
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#7045
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#7043
  def type_check(_symtab); end

  # source://idlc//lib/idlc/ast.rb#7050
  def value(_symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#7065
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::StringLiteralAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#7014
module Idl::StringLiteralSyntaxNode
  # source://idlc//lib/idlc/ast.rb#7015
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#989
Idl::StringType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/idl_parser.rb#1191
module Idl::StructDefinition0
  # source://idlc//lib/idlc/idl_parser.rb#1196
  def id; end

  # source://idlc//lib/idlc/idl_parser.rb#1192
  def type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#1202
module Idl::StructDefinition1
  # source://idlc//lib/idlc/idl_parser.rb#1207
  def member; end

  # source://idlc//lib/idlc/idl_parser.rb#1203
  def user_type_name; end
end

# source://idlc//lib/idlc/ast.rb#2259
class Idl::StructDefinitionAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#2274
  def initialize(input, interval, name, member_types, member_names); end

  # source://idlc//lib/idlc/ast.rb#2302
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#2272
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#2269
  def member_names; end

  # source://idlc//lib/idlc/ast.rb#2313
  def member_type(name, symtab); end

  # source://idlc//lib/idlc/ast.rb#2266
  def member_types; end

  # source://idlc//lib/idlc/ast.rb#2263
  def name; end

  # source://idlc//lib/idlc/ast.rb#2320
  def num_members; end

  # source://idlc//lib/idlc/ast.rb#2332
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#2323
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2291
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#2283
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#2345
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#2238
class Idl::StructDefinitionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2239
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#584
class Idl::StructType < ::Idl::Type
  # source://idlc//lib/idlc/type.rb#589
  sig { params(type_name: ::String, member_types: T::Array[::Idl::Type], member_names: T::Array[::String]).void }
  def initialize(type_name, member_types, member_names); end

  # source://idlc//lib/idlc/type.rb#599
  def clone; end

  # source://idlc//lib/idlc/type.rb#603
  def default; end

  # source://idlc//lib/idlc/type.rb#611
  def member?(name); end

  # source://idlc//lib/idlc/type.rb#613
  def member_type(member_name); end

  # source://idlc//lib/idlc/type.rb#597
  sig { returns(::String) }
  def name; end

  # source://idlc//lib/idlc/type.rb#621
  def runtime?; end

  # source://idlc//lib/idlc/type.rb#586
  sig { returns(::String) }
  def type_name; end
end

# source://idlc//lib/idlc/symbol_table.rb#122
class Idl::SymbolTable
  # source://idlc//lib/idlc/symbol_table.rb#237
  sig do
    params(
      mxlen: T.nilable(::Integer),
      possible_xlens_cb: T.nilable(T.proc.returns(T::Array[::Integer])),
      builtin_global_vars: T::Array[::Idl::Var],
      builtin_enums: T::Array[::Idl::SymbolTable::EnumDef],
      builtin_funcs: T.nilable(::Idl::SymbolTable::BuiltinFunctionCallbacks),
      csrs: T::Array[::Idl::Csr],
      params: T::Array[::Idl::RuntimeParam],
      name: ::String
    ).void
  end
  def initialize(mxlen: T.unsafe(nil), possible_xlens_cb: T.unsafe(nil), builtin_global_vars: T.unsafe(nil), builtin_enums: T.unsafe(nil), builtin_funcs: T.unsafe(nil), csrs: T.unsafe(nil), params: T.unsafe(nil), name: T.unsafe(nil)); end

  # source://idlc//lib/idlc/symbol_table.rb#409
  def add(name, var); end

  # source://idlc//lib/idlc/symbol_table.rb#418
  def add!(name, var); end

  # source://idlc//lib/idlc/symbol_table.rb#435
  def add_above!(name, var); end

  # source://idlc//lib/idlc/symbol_table.rb#444
  def add_at!(level, name, var); end

  # source://idlc//lib/idlc/symbol_table.rb#468
  def at_global_scope?; end

  # source://idlc//lib/idlc/symbol_table.rb#206
  def builtin_funcs; end

  # source://idlc//lib/idlc/symbol_table.rb#343
  def callstack; end

  # source://idlc//lib/idlc/symbol_table.rb#215
  sig { params(csr_name: ::String).returns(T.nilable(::Idl::Csr)) }
  def csr(csr_name); end

  # source://idlc//lib/idlc/symbol_table.rb#209
  sig { params(csr_name: ::String).returns(T::Boolean) }
  def csr?(csr_name); end

  # source://idlc//lib/idlc/symbol_table.rb#212
  sig { returns(T::Hash[::String, ::Idl::Csr]) }
  def csr_hash; end

  # source://idlc//lib/idlc/symbol_table.rb#518
  def deep_clone(clone_values: T.unsafe(nil), freeze_global: T.unsafe(nil)); end

  # source://idlc//lib/idlc/symbol_table.rb#287
  def deep_freeze; end

  # source://idlc//lib/idlc/symbol_table.rb#428
  def del(name); end

  # source://idlc//lib/idlc/symbol_table.rb#389
  def find_all(single_scope: T.unsafe(nil), &block); end

  # source://idlc//lib/idlc/symbol_table.rb#359
  def get(name); end

  # source://idlc//lib/idlc/symbol_table.rb#367
  def get_from(name, level); end

  # source://idlc//lib/idlc/symbol_table.rb#379
  def get_global(name); end

  # source://idlc//lib/idlc/symbol_table.rb#473
  def global_clone; end

  # source://idlc//lib/idlc/symbol_table.rb#136
  def hash; end

  # source://idlc//lib/idlc/symbol_table.rb#515
  def in_use?; end

  # source://idlc//lib/idlc/symbol_table.rb#282
  sig { returns(::String) }
  def inspect; end

  # source://idlc//lib/idlc/symbol_table.rb#348
  def key?(name); end

  # source://idlc//lib/idlc/symbol_table.rb#352
  def keys_pretty; end

  # source://idlc//lib/idlc/symbol_table.rb#453
  def levels; end

  # source://idlc//lib/idlc/symbol_table.rb#159
  sig { returns(T::Boolean) }
  def multi_xlen?; end

  # source://idlc//lib/idlc/symbol_table.rb#128
  sig { returns(T.nilable(::Integer)) }
  def mxlen; end

  # source://idlc//lib/idlc/symbol_table.rb#131
  sig { returns(::String) }
  def name; end

  # source://idlc//lib/idlc/symbol_table.rb#218
  sig { params(param_name: ::String).returns(T.nilable(::Idl::RuntimeParam)) }
  def param(param_name); end

  # source://idlc//lib/idlc/symbol_table.rb#221
  sig { returns(T::Hash[::String, ::Idl::RuntimeParam]) }
  def params_hash; end

  # source://idlc//lib/idlc/symbol_table.rb#333
  def pop; end

  # source://idlc//lib/idlc/symbol_table.rb#167
  sig { returns(T::Array[::Integer]) }
  def possible_xlens; end

  # source://idlc//lib/idlc/symbol_table.rb#459
  sig { void }
  def print; end

  # source://idlc//lib/idlc/symbol_table.rb#321
  def push(ast); end

  # source://idlc//lib/idlc/symbol_table.rb#504
  def release; end

  class << self
    # source://idlc//lib/idlc/symbol_table.rb#184
    sig do
      params(
        blk: T.proc.params(arg0: ::String).returns(T.nilable(T::Boolean))
      ).returns(T.proc.params(arg0: ::String).returns(T.nilable(T::Boolean)))
    end
    def make_implemented_callback(&blk); end

    # source://idlc//lib/idlc/symbol_table.rb#198
    sig do
      params(
        blk: T.proc.params(arg0: ::Integer).returns(T.nilable(T::Boolean))
      ).returns(T.proc.params(arg0: ::Integer).returns(T.nilable(T::Boolean)))
    end
    def make_implemented_csr_callback(&blk); end

    # source://idlc//lib/idlc/symbol_table.rb#191
    sig do
      params(
        blk: T.proc.params(arg0: ::String, arg1: ::String).returns(T.nilable(T::Boolean))
      ).returns(T.proc.params(arg0: ::String, arg1: ::String).returns(T.nilable(T::Boolean)))
    end
    def make_implemented_version_callback(&blk); end
  end
end

# source://idlc//lib/idlc/symbol_table.rb#200
class Idl::SymbolTable::BuiltinFunctionCallbacks < ::T::Struct
  prop :implemented, T.proc.params(arg0: ::String).returns(T.nilable(T::Boolean))
  prop :implemented_version, T.proc.params(arg0: ::String, arg1: ::String).returns(T.nilable(T::Boolean))
  prop :implemented_csr, T.proc.params(arg0: ::Integer).returns(T.nilable(T::Boolean))

  class << self
    # source://sorbet-runtime/0.6.12690/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://idlc//lib/idlc/symbol_table.rb#133
class Idl::SymbolTable::DuplicateSymError < ::StandardError; end

# source://idlc//lib/idlc/symbol_table.rb#142
class Idl::SymbolTable::EnumDef < ::T::Struct
  prop :name, ::String
  prop :element_values, T::Array[::Integer]
  prop :element_names, T::Array[::String]

  # source://idlc//lib/idlc/symbol_table.rb#150
  sig { params(name: ::String, element_values: T::Array[::Integer], element_names: T::Array[::String]).void }
  def initialize(name:, element_values:, element_names:); end

  class << self
    # source://sorbet-runtime/0.6.12690/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://idlc//lib/idlc/symbol_table.rb#179
Idl::SymbolTable::ImplementedCallbackType = T.type_alias { T.proc.params(arg0: ::String).returns(T.nilable(T::Boolean)) }

# source://idlc//lib/idlc/symbol_table.rb#193
Idl::SymbolTable::ImplementedCsrCallbackType = T.type_alias { T.proc.params(arg0: ::Integer).returns(T.nilable(T::Boolean)) }

# source://idlc//lib/idlc/symbol_table.rb#186
Idl::SymbolTable::ImplementedVersionCallbackType = T.type_alias { T.proc.params(arg0: ::String, arg1: ::String).returns(T.nilable(T::Boolean)) }

# source://idlc//lib/idlc/symbol_table.rb#161
class Idl::SymbolTable::MemoizedState < ::T::Struct
  prop :possible_xlens, T.nilable(T::Array[::Integer])
  prop :params_hash, T.nilable(T::Hash[::String, ::Idl::RuntimeParam])

  class << self
    # source://sorbet-runtime/0.6.12690/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://idlc//lib/idlc/symbol_table.rb#156
Idl::SymbolTable::PossibleXlensCallbackType = T.type_alias { T.proc.returns(T::Array[::Integer]) }

# source://idlc//lib/idlc/syntax_node.rb#49
class Idl::SyntaxNode < ::Treetop::Runtime::SyntaxNode
  # source://idlc//lib/idlc/syntax_node.rb#54
  sig { overridable.returns(::Idl::AstNode) }
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#3969
module Idl::TemplateSafeP3BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#3970
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#3974
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#3979
module Idl::TemplateSafeP3BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#3980
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#3984
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4205
module Idl::TemplateSafeP4BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#4206
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#4210
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4215
module Idl::TemplateSafeP4BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#4216
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#4220
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4441
module Idl::TemplateSafeP5BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#4442
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#4446
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4451
module Idl::TemplateSafeP5BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#4452
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#4456
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4677
module Idl::TemplateSafeP6BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#4678
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#4682
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4687
module Idl::TemplateSafeP6BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#4688
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#4692
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4913
module Idl::TemplateSafeP7BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#4914
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#4918
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#4923
module Idl::TemplateSafeP7BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#4924
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#4928
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#5149
module Idl::TemplateSafeP8BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5150
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#5154
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#5159
module Idl::TemplateSafeP8BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#5160
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#5164
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#5385
module Idl::TemplateSafeP9BinaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#5386
  def op; end

  # source://idlc//lib/idlc/idl_parser.rb#5390
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#5395
module Idl::TemplateSafeP9BinaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#5396
  def l; end

  # source://idlc//lib/idlc/idl_parser.rb#5400
  def r; end
end

# source://idlc//lib/idlc/idl_parser.rb#7889
module Idl::TemplateSafeTernaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#7890
  def e; end

  # source://idlc//lib/idlc/idl_parser.rb#7898
  def f; end

  # source://idlc//lib/idlc/idl_parser.rb#7894
  def t; end
end

# source://idlc//lib/idlc/idl_parser.rb#7768
module Idl::TernaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#7769
  def e; end

  # source://idlc//lib/idlc/idl_parser.rb#7777
  def f; end

  # source://idlc//lib/idlc/idl_parser.rb#7773
  def t; end
end

# source://idlc//lib/idlc/ast.rb#6102
class Idl::TernaryOperatorExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#6112
  def initialize(input, interval, condition, true_expression, false_expression); end

  # source://idlc//lib/idlc/ast.rb#6108
  def condition; end

  # source://idlc//lib/idlc/ast.rb#6106
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6110
  def false_expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#186
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#123
  def gen_option_adoc; end

  # source://idlc//lib/idlc/passes/prune.rb#456
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#6204
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6201
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#6109
  def true_expression; end

  # source://idlc//lib/idlc/ast.rb#6144
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#6117
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#6185
  def value(symtab); end

  # source://idlc//lib/idlc/ast.rb#6190
  def values(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6213
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::TernaryOperatorExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#6091
class Idl::TernaryOperatorExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#6092
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#873
class Idl::TrueExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#877
  sig { params(input: ::String, interval: T::Range[::Integer]).void }
  def initialize(input, interval); end

  # source://idlc//lib/idlc/ast.rb#882
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#148
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/passes/gen_option_adoc.rb#89
  def gen_option_adoc; end

  # source://idlc//lib/idlc/ast.rb#897
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#894
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/../../udb/lib/udb/idl/condition_to_udb.rb#66
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#888
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#885
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#891
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::TrueClass) }
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#903
    sig do
      override
        .params(
          yaml: T::Hash[::String, T.untyped],
          source_mapper: T::Hash[::String, ::String]
        ).returns(::Idl::AstNode)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#869
class Idl::TrueExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#870
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#15
class Idl::Type
  # source://idlc//lib/idlc/type.rb#119
  def initialize(kind, qualifiers: T.unsafe(nil), width: T.unsafe(nil), width_ast: T.unsafe(nil), max_width: T.unsafe(nil), sub_type: T.unsafe(nil), name: T.unsafe(nil), tuple_types: T.unsafe(nil), return_type: T.unsafe(nil), arguments: T.unsafe(nil), enum_class: T.unsafe(nil), csr: T.unsafe(nil)); end

  # source://idlc//lib/idlc/type.rb#382
  def ary?; end

  # source://idlc//lib/idlc/type.rb#235
  def ary_type(ary); end

  # source://idlc//lib/idlc/type.rb#160
  def clone; end

  # source://idlc//lib/idlc/type.rb#175
  def comparable_to?(type); end

  # source://idlc//lib/idlc/type.rb#386
  def const?; end

  # source://idlc//lib/idlc/type.rb#245
  def convertable_to?(type); end

  # source://idlc//lib/idlc/type.rb#56
  def default; end

  # source://idlc//lib/idlc/type.rb#98
  sig { returns(::Idl::EnumerationType) }
  def enum_class; end

  # source://idlc//lib/idlc/type.rb#207
  def equal_to?(type); end

  # source://idlc//lib/idlc/type.rb#334
  def fully_qualified_name; end

  # source://idlc//lib/idlc/type.rb#398
  def global?; end

  # source://idlc//lib/idlc/type.rb#44
  sig { returns(T::Boolean) }
  def integral?; end

  # source://idlc//lib/idlc/type.rb#80
  sig { returns(::Symbol) }
  def kind; end

  # source://idlc//lib/idlc/type.rb#406
  def known?; end

  # source://idlc//lib/idlc/type.rb#424
  sig { returns(::Idl::Type) }
  def make_const; end

  # source://idlc//lib/idlc/type.rb#417
  sig { returns(::Idl::Type) }
  def make_const!; end

  # source://idlc//lib/idlc/type.rb#429
  def make_global; end

  # source://idlc//lib/idlc/type.rb#434
  def make_known; end

  # source://idlc//lib/idlc/type.rb#410
  def make_signed; end

  # source://idlc//lib/idlc/type.rb#390
  def mutable?; end

  # source://idlc//lib/idlc/type.rb#364
  def name; end

  # source://idlc//lib/idlc/type.rb#83
  sig { returns(T::Array[::Symbol]) }
  def qualifiers; end

  # source://idlc//lib/idlc/type.rb#100
  def qualify(qualifier); end

  # source://idlc//lib/idlc/type.rb#48
  def runtime?; end

  # source://idlc//lib/idlc/type.rb#394
  def signed?; end

  # source://idlc//lib/idlc/type.rb#92
  sig { returns(::Idl::Type) }
  def sub_type; end

  # source://idlc//lib/idlc/type.rb#402
  def template_var?; end

  # source://idlc//lib/idlc/type.rb#314
  sig { returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/type.rb#334
  def to_s; end

  # source://idlc//lib/idlc/type.rb#95
  sig { returns(T::Array[::Idl::Type]) }
  def tuple_types; end

  # source://idlc//lib/idlc/type.rb#86
  sig { returns(T.any(::Integer, ::Symbol)) }
  def width; end

  # source://idlc//lib/idlc/type.rb#89
  sig { returns(T.nilable(::Idl::AstNode)) }
  def width_ast; end

  class << self
    # source://idlc//lib/idlc/type.rb#567
    sig { params(schema: T::Hash[::String, T.untyped]).returns(T.nilable(::Idl::Type)) }
    def from_json_schema(schema); end

    # source://idlc//lib/idlc/type.rb#106
    def from_typename(type_name, cfg_arch); end

    private

    # source://idlc//lib/idlc/type.rb#529
    sig { params(schema: T::Hash[::String, T.untyped]).returns(::Idl::Type) }
    def from_json_schema_array_type(schema); end

    # source://idlc//lib/idlc/type.rb#442
    sig { params(schema: T::Hash[::String, T.untyped]).returns(T.nilable(::Idl::Type)) }
    def from_json_schema_scalar_type(schema); end
  end
end

# source://idlc//lib/idlc/type.rb#18
Idl::Type::KINDS = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/type.rb#34
Idl::Type::QUALIFIERS = T.let(T.unsafe(nil), Array)

# source://idlc//lib/idlc/type.rb#158
Idl::Type::TYPE_FROM_KIND = T.let(T.unsafe(nil), Hash)

# source://idlc//lib/idlc/ast.rb#7844
Idl::TypeNameAst = T.type_alias { T.any(::Idl::BuiltinTypeNameAst, ::Idl::UserTypeNameAst) }

# source://idlc//lib/idlc/idl_parser.rb#6782
module Idl::UnaryExpression0
  # source://idlc//lib/idlc/idl_parser.rb#6783
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#6788
module Idl::UnaryExpression1
  # source://idlc//lib/idlc/idl_parser.rb#6789
  def first; end

  # source://idlc//lib/idlc/idl_parser.rb#6793
  def rest; end
end

# source://idlc//lib/idlc/idl_parser.rb#6799
module Idl::UnaryExpression2
  # source://idlc//lib/idlc/idl_parser.rb#6800
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#6806
module Idl::UnaryExpression3
  # source://idlc//lib/idlc/idl_parser.rb#6807
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#6813
module Idl::UnaryExpression4
  # source://idlc//lib/idlc/idl_parser.rb#6814
  def user_type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#6820
module Idl::UnaryExpression5
  # source://idlc//lib/idlc/idl_parser.rb#6821
  def user_type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#6827
module Idl::UnaryExpression6
  # source://idlc//lib/idlc/idl_parser.rb#6832
  def expression; end

  # source://idlc//lib/idlc/idl_parser.rb#6828
  def user_type_name; end
end

# source://idlc//lib/idlc/idl_parser.rb#6838
module Idl::UnaryExpression7
  # source://idlc//lib/idlc/idl_parser.rb#6839
  def expression; end
end

# source://idlc//lib/idlc/idl_parser.rb#6845
module Idl::UnaryExpression8
  # source://idlc//lib/idlc/idl_parser.rb#6846
  def ary; end

  # source://idlc//lib/idlc/idl_parser.rb#6850
  def value; end
end

# source://idlc//lib/idlc/idl_parser.rb#6856
module Idl::UnaryExpression9
  # source://idlc//lib/idlc/idl_parser.rb#6861
  def e; end

  # source://idlc//lib/idlc/idl_parser.rb#6857
  def o; end
end

# source://idlc//lib/idlc/ast.rb#5959
class Idl::UnaryOperatorExpressionAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#5967
  def initialize(input, interval, op, expression); end

  # source://idlc//lib/idlc/ast.rb#5963
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#6056
  def exp; end

  # source://idlc//lib/idlc/ast.rb#5965
  def expression; end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#265
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#5973
  def invert(symtab); end

  # source://idlc//lib/idlc/ast.rb#6061
  def op; end

  # source://idlc//lib/idlc/ast.rb#6070
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#6067
  sig { override.returns(::String) }
  def to_idl; end

  # source://udb/0.1.0/../../udb/lib/udb/idl/condition_to_udb.rb#126
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T.any(T::Boolean, T::Hash[::String, T.untyped])) }
  def to_udb_h(symtab); end

  # source://idlc//lib/idlc/ast.rb#5984
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#6000
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#6028
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#6078
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::UnaryOperatorExpressionAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#5947
class Idl::UnaryOperatorExpressionSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#5948
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#7083
class Idl::UnknownLiteral
  # source://idlc//lib/idlc/ast.rb#7085
  def initialize(known_value, unknown_mask); end

  # source://idlc//lib/idlc/ast.rb#7093
  def &(other); end

  # source://idlc//lib/idlc/ast.rb#7114
  def ==(other); end

  # source://idlc//lib/idlc/ast.rb#7089
  def bit_length; end

  # source://idlc//lib/idlc/ast.rb#7084
  def known_value; end

  # source://idlc//lib/idlc/ast.rb#7144
  def to_s; end

  # source://idlc//lib/idlc/ast.rb#7084
  def unknown_mask; end

  # source://idlc//lib/idlc/ast.rb#7092
  def zero?; end

  # source://idlc//lib/idlc/ast.rb#7123
  def |(other); end
end

# source://idlc//lib/idlc/idl_parser.rb#15764
module Idl::UserTypeName0; end

# source://idlc//lib/idlc/ast.rb#7792
class Idl::UserTypeNameAst < ::Idl::AstNode
  # source://idlc//lib/idlc/ast.rb#7796
  def initialize(input, interval, name); end

  # source://idlc//lib/idlc/ast.rb#7794
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#66
  def gen_adoc(indent, indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#7802
  def text_value; end

  # source://idlc//lib/idlc/ast.rb#7825
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#7822
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#7813
  sig { params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#7805
  def type_check(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#7832
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::UserTypeNameAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#7786
class Idl::UserTypeNameSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#7787
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#27
Idl::ValueRbType = T.type_alias { T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean, T::Hash[::String, T.any(::Integer, ::String, T::Array[::Integer], T::Array[::String], T::Array[T::Boolean], T::Boolean)]) }

# source://idlc//lib/idlc/symbol_table.rb#17
class Idl::Var
  # source://idlc//lib/idlc/symbol_table.rb#22
  def initialize(name, type, value = T.unsafe(nil), decode_var: T.unsafe(nil), template_index: T.unsafe(nil), function_name: T.unsafe(nil), param: T.unsafe(nil), for_loop_iter: T.unsafe(nil)); end

  # source://idlc//lib/idlc/symbol_table.rb#68
  def clone; end

  # source://idlc//lib/idlc/symbol_table.rb#80
  def const?; end

  # source://idlc//lib/idlc/symbol_table.rb#47
  sig { returns(T::Boolean) }
  def const_eval?; end

  # source://idlc//lib/idlc/symbol_table.rb#42
  sig { void }
  def const_incompatible!; end

  # source://idlc//lib/idlc/symbol_table.rb#84
  def decode_var?; end

  # source://idlc//lib/idlc/symbol_table.rb#56
  sig { returns(T::Boolean) }
  def for_loop_iter?; end

  # source://idlc//lib/idlc/symbol_table.rb#60
  def hash; end

  # source://idlc//lib/idlc/symbol_table.rb#20
  def name; end

  # source://idlc//lib/idlc/symbol_table.rb#88
  def param?; end

  # source://idlc//lib/idlc/symbol_table.rb#102
  def template_index; end

  # source://idlc//lib/idlc/symbol_table.rb#108
  def template_val?; end

  # source://idlc//lib/idlc/symbol_table.rb#98
  def template_value?; end

  # source://idlc//lib/idlc/symbol_table.rb#94
  def template_value_for?(function_name); end

  # source://idlc//lib/idlc/symbol_table.rb#112
  def to_cxx; end

  # source://idlc//lib/idlc/symbol_table.rb#64
  def to_s; end

  # source://idlc//lib/idlc/symbol_table.rb#20
  def type; end

  # source://idlc//lib/idlc/symbol_table.rb#20
  def value; end

  # source://idlc//lib/idlc/symbol_table.rb#116
  def value=(new_value); end
end

# source://idlc//lib/idlc/idl_parser.rb#16508
module Idl::VarWrite0
  # source://idlc//lib/idlc/idl_parser.rb#16509
  def csr_name; end
end

# source://idlc//lib/idlc/ast.rb#2684
class Idl::VariableAssignmentAst < ::Idl::AstNode
  include ::Idl::Executable

  # source://idlc//lib/idlc/ast.rb#2708
  def initialize(input, interval, lhs_ast, rhs_ast); end

  # source://idlc//lib/idlc/ast.rb#2688
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#2739
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#2760
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#241
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#2703
  sig { returns(::Idl::IdAst) }
  def lhs; end

  # source://idlc//lib/idlc/passes/prune.rb#74
  def nullify_assignments(symtab); end

  # source://idlc//lib/idlc/passes/prune.rb#69
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#2706
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#2777
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#2774
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#2714
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#2729
  def var(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#2785
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::VariableAssignmentAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#2673
class Idl::VariableAssignmentSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#2674
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#3551
class Idl::VariableDeclarationAst < ::Idl::AstNode
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#3581
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      type_name: T.any(::Idl::BuiltinTypeNameAst, ::Idl::UserTypeNameAst),
      id: ::Idl::IdAst,
      ary_size: T.nilable(T.all(::Idl::AstNode, ::Idl::Rvalue))
    ).void
  end
  def initialize(input, interval, type_name, id, ary_size); end

  # source://idlc//lib/idlc/ast.rb#3651
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#3567
  sig { returns(T.nilable(T.all(::Idl::AstNode, ::Idl::Rvalue))) }
  def ary_size; end

  # source://idlc//lib/idlc/ast.rb#3555
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#3597
  sig { params(symtab: ::Idl::SymbolTable).returns(T.nilable(::Idl::Type)) }
  def decl_type(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#174
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#3564
  sig { returns(::Idl::IdAst) }
  def id; end

  # source://idlc//lib/idlc/ast.rb#3592
  sig { void }
  def make_global; end

  # source://idlc//lib/idlc/ast.rb#3570
  sig { returns(::String) }
  def name; end

  # source://idlc//lib/idlc/ast.rb#3672
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#3663
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#3622
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#3625
  def type_check(symtab, add_sym = T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#3561
  sig { returns(T.any(::Idl::BuiltinTypeNameAst, ::Idl::UserTypeNameAst)) }
  def type_name; end

  class << self
    # source://idlc//lib/idlc/ast.rb#3684
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::VariableDeclarationAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#3540
class Idl::VariableDeclarationSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3541
  def to_ast; end
end

# source://idlc//lib/idlc/ast.rb#3734
class Idl::VariableDeclarationWithInitializationAst < ::Idl::AstNode
  include ::Idl::Executable
  include ::Idl::Declaration

  # source://idlc//lib/idlc/ast.rb#3776
  sig do
    params(
      input: T.nilable(::String),
      interval: T.nilable(T::Range[::Integer]),
      type_name_ast: T.any(::Idl::BuiltinTypeNameAst, ::Idl::UserTypeNameAst),
      var_write_ast: ::Idl::IdAst,
      ary_size: T.nilable(T.all(::Idl::AstNode, ::Idl::Rvalue)),
      rval_ast: T.all(::Idl::AstNode, ::Idl::Rvalue),
      is_for_loop_iteration_var: T::Boolean
    ).void
  end
  def initialize(input, interval, type_name_ast, var_write_ast, ary_size, rval_ast, is_for_loop_iteration_var); end

  # source://idlc//lib/idlc/ast.rb#3850
  def add_symbol(symtab); end

  # source://idlc//lib/idlc/ast.rb#3757
  sig { returns(T.nilable(T.all(::Idl::AstNode, ::Idl::Rvalue))) }
  def ary_size; end

  # source://idlc//lib/idlc/ast.rb#3739
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#3880
  def execute(symtab); end

  # source://idlc//lib/idlc/ast.rb#3896
  def execute_unknown(symtab); end

  # source://idlc//lib/idlc/passes/gen_adoc.rb#219
  def gen_adoc(indent = T.unsafe(nil), indent_spaces: T.unsafe(nil)); end

  # source://idlc//lib/idlc/ast.rb#3763
  sig { returns(::String) }
  def id; end

  # source://idlc//lib/idlc/ast.rb#3754
  sig { returns(::Idl::IdAst) }
  def lhs; end

  # source://idlc//lib/idlc/ast.rb#3790
  def lhs_type(symtab); end

  # source://idlc//lib/idlc/ast.rb#3786
  def make_global; end

  # source://idlc//lib/idlc/passes/prune.rb#93
  def prune(symtab); end

  # source://idlc//lib/idlc/ast.rb#3760
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def rhs; end

  # source://idlc//lib/idlc/ast.rb#3911
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#3902
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#3817
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#3751
  sig { returns(T.any(::Idl::BuiltinTypeNameAst, ::Idl::UserTypeNameAst)) }
  def type_name; end

  class << self
    # source://idlc//lib/idlc/ast.rb#3925
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::VariableDeclarationWithInitializationAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#3707
class Idl::VariableDeclarationWithInitializationSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#3708
  def to_ast; end
end

# source://idlc//lib/idlc/idl_parser.rb#1394
module Idl::VersionString0; end

# source://idlc//lib/idlc/type.rb#988
Idl::VoidType = T.let(T.unsafe(nil), Idl::Type)

# source://idlc//lib/idlc/ast.rb#4184
class Idl::WidthRevealAst < ::Idl::AstNode
  include ::Idl::Rvalue

  # source://idlc//lib/idlc/ast.rb#4194
  sig { params(input: T.nilable(::String), interval: T.nilable(T::Range[::Integer]), e: ::Idl::AstNode).void }
  def initialize(input, interval, e); end

  # source://idlc//lib/idlc/ast.rb#4188
  sig { override.params(symtab: ::Idl::SymbolTable).returns(T::Boolean) }
  def const_eval?(symtab); end

  # source://idlc//lib/idlc/ast.rb#4191
  sig { returns(T.all(::Idl::AstNode, ::Idl::Rvalue)) }
  def expression; end

  # source://idlc//lib/idlc/ast.rb#4226
  sig { override.returns(T::Hash[::String, T.untyped]) }
  def to_h; end

  # source://idlc//lib/idlc/ast.rb#4223
  sig { override.returns(::String) }
  def to_idl; end

  # source://idlc//lib/idlc/ast.rb#4207
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Idl::Type) }
  def type(symtab); end

  # source://idlc//lib/idlc/ast.rb#4199
  sig { override.params(symtab: ::Idl::SymbolTable).void }
  def type_check(symtab); end

  # source://idlc//lib/idlc/ast.rb#4216
  sig { override.params(symtab: ::Idl::SymbolTable).returns(::Integer) }
  def value(symtab); end

  class << self
    # source://idlc//lib/idlc/ast.rb#4233
    sig do
      params(
        yaml: T::Hash[::String, T.untyped],
        source_mapper: T::Hash[::String, ::String]
      ).returns(::Idl::WidthRevealAst)
    end
    def from_h(yaml, source_mapper); end
  end
end

# source://idlc//lib/idlc/ast.rb#4178
class Idl::WidthRevealSyntaxNode < ::Idl::SyntaxNode
  # source://idlc//lib/idlc/ast.rb#4179
  def to_ast; end
end

# source://idlc//lib/idlc/type.rb#966
class Idl::XregType < ::Idl::Type
  # source://idlc//lib/idlc/type.rb#967
  def initialize(xlen); end

  # source://idlc//lib/idlc/type.rb#975
  def to_cxx; end

  # source://idlc//lib/idlc/type.rb#971
  def to_s; end
end

# source://idlc//lib/idlc.rb#13
class IdlParser < ::Treetop::Runtime::CompiledParser
  include ::Idl

  # source://idlc//lib/idlc.rb#14
  def input_file; end

  # source://idlc//lib/idlc.rb#35
  def instantiate_node(node_type, *args); end

  # source://idlc//lib/idlc.rb#16
  def set_input_file(filename, starting_line = T.unsafe(nil)); end

  # source://idlc//lib/idlc.rb#21
  def set_pb(pb); end

  # source://idlc//lib/idlc.rb#27
  def unset_pb; end

  protected

  # source://treetop/1.6.12/lib/treetop/runtime/compiled_parser.rb#98
  def idlc_instantiate_node(node_type, *args); end
end

class Object < ::BasicObject
  include ::Kernel
  include ::PP::ObjectMixin
  include ::Udb::Helpers::WavedromUtil

  private

  # source://idlc//lib/idlc/passes/prune.rb#19
  def create_bool_literal(value); end

  # source://idlc//lib/idlc/passes/prune.rb#14
  def create_int_literal(value); end

  # source://idlc//lib/idlc/passes/prune.rb#27
  def create_literal(symtab, value, type); end
end

# source://idlc//lib/idlc/syntax_node.rb#11
module Treetop
  class << self
    # source://treetop/1.6.12/lib/treetop/compiler/grammar_compiler.rb#35
    def load(path); end

    # source://treetop/1.6.12/lib/treetop/compiler/grammar_compiler.rb#48
    def load_from_string(s); end
  end
end

# source://idlc//lib/idlc/syntax_node.rb#12
module Treetop::Runtime; end

# source://idlc//lib/idlc/syntax_node.rb#13
class Treetop::Runtime::SyntaxNode
  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#7
  def initialize(input, interval, elements = T.unsafe(nil)); end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#47
  def <=>(other); end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#98
  def dot_id; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#15
  def elements; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#43
  def empty?; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#51
  def extension_modules; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#4
  def input; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#91
  def inspect(indent = T.unsafe(nil)); end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#78
  def inspect_children(indent = T.unsafe(nil)); end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#63
  def inspect_self(indent = T.unsafe(nil)); end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#4
  def interval; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#35
  def nonterminal?; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#5
  def parent; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#5
  def parent=(_arg0); end

  # source://idlc//lib/idlc/syntax_node.rb#20
  sig { params(filename: T.nilable(::String), starting_line: ::Integer).void }
  def set_input_file(filename, starting_line = T.unsafe(nil)); end

  # source://idlc//lib/idlc/syntax_node.rb#39
  sig { params(filename: T.nilable(::String), starting_line: ::Integer).void }
  def set_input_file_unless_already_set(filename, starting_line = T.unsafe(nil)); end

  # source://idlc//lib/idlc/syntax_node.rb#30
  sig { returns(T::Boolean) }
  def space?; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#31
  def terminal?; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#39
  def text_value; end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#102
  def write_dot(io); end

  # source://treetop/1.6.12/lib/treetop/runtime/syntax_node.rb#113
  def write_dot_file(fname); end
end

module UdbGems; end
