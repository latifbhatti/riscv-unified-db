# Copyright (c) Qualcomm Technologies, Inc. and/or its subsidiaries.
# SPDX-License-Identifier: BSD-3-Clause-Clear

# yaml-language-server: $schema=../../../../../schemas/inst_schema.json

$schema: inst_schema.json#
kind: instruction
name: qc.wrapi
long_name: Wraparound (Unsigned Immediate)
description: |
  If `xs1` >= `uimm` perform subtraction between `xs1` and `uimm`.
  If `xs1` < 0, perform addition between `xs1` and `uimm`,
  else, select `xs1`. The result is stored in `xd`.
  The `uimm` is an unsigned immediate.
definedBy:
  allOf:
    - xlen: 32
    - extension:
        name: Xqcia
format:
  size: 32
  operands:
    - $ref: inst_operand/qc.uimm11.yaml#
    - $ref: inst_operand/qc.xs1-n0.yaml#
    - $ref: inst_operand/xd-n0.yaml#
  opcodes:
    - displayName: f1
      location: 31
      value: 0b0
    - displayName: funct3
      location: 14-12
      value: 0b000
    - $ref: inst_opcode/custom-0.yaml#
assembly: xd, xs1, uimm
access:
  s: always
  u: always
  vs: always
  vu: always
operation(): |
  XReg xs1_value = X[xs1];

  # IDL will only compare signed to signed, so $signed({1'b0, uimm}) is a way to make the
  # unsigned `uimm` into a signed type
  X[xd] = ($signed(xs1_value) >= $signed({1'b0, uimm}))
    ? xs1_value - uimm
    : (($signed(xs1_value) < 's0)
       ? ($signed(xs1_value) + uimm)
       : xs1_value);
