# yaml-language-server: $schema=../../../schemas/inst_schema.json

$schema: "inst_schema.json#"
kind: instruction
name: vmslt.vv
long_name: No synopsis available.
description: |
  No description available.
definedBy: V
assembly: vm, vs2, vs1, vd
encoding:
  match: 011011-----------000-----1010111
  variables:
    - name: vm
      location: 25-25
    - name: vs2
      location: 24-20
    - name: vs1
      location: 19-15
    - name: vd
      location: 11-7
access:
  s: always
  u: always
  vs: always
  vu: always
data_independent_timing: false
operation(): |
  U32 SEW = 32;                                    #from vtype vcsr
  U32 vstart = 0;                                  # from vcsr
  U32 M1 = 1;                                      #from vtype vcsr
  U32 VLEN = 128 ;                                 #fron config file
  U32 ELEN = 32;                                   #from config file
  U32 vec_result = 0;
  U32 lmul_increment = 0;                        # After implementing the 2D parser, remove the lmul_increment variable.


    #for (U32 lmul_increment = 0; lmul_increment < M1; lmul_increment++) {          # define value of LMUL from CSR (for grouping) (Uncomment after adding the 2D parser in IDL)
      for (U32 j = 0; j < ((M1 * VLEN )/ ELEN); j++) { # To find total elements according to ELEN
        U32 sew_increment = SEW;                        # from vcsr(sew)
        for (U32 k = 0; k < ELEN/SEW; k++) {       # for sew selection
          vec_result[vstart%ELEN] = # for grouping [vd+lmul_increment][vstart%ELEN] (Uncomment after adding the 2D parser in IDL)
          vector_comparison_instructions(
            ($signed(X[vs2+lmul_increment][sew_increment-1:sew_increment-SEW]) < $signed(X[vs1+lmul_increment][sew_increment-1:sew_increment-SEW])) ? 1 : 0,
            X[vd][vstart%ELEN],                                                                            #vs3 for previous data()
            X[0][vstart%ELEN],                                                                                             #masking bit from vs0
            $encoding
          );
          vstart = vstart + 1;
          sew_increment = sew_increment + SEW;
        }
        X[vd + lmul_increment] = vec_result;
      }
    #}

sail(): |
  {
    let SEW      = get_sew();
    let LMUL_pow = get_lmul_pow();
    let num_elem = get_num_elem(LMUL_pow, SEW);

    if illegal_vd_unmasked() then { handle_illegal(); return RETIRE_FAIL };

    let 'n = num_elem;
    let 'm = SEW;

    let vm_val  : vector('n, dec, bool)     = read_vmask(num_elem, vm, 0b00000);
    let vs1_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs1);
    let vs2_val : vector('n, dec, bits('m)) = read_vreg(num_elem, SEW, LMUL_pow, vs2);
    let vd_val  : vector('n, dec, bool)     = read_vmask(num_elem, 0b0, vd);
    result      : vector('n, dec, bool)     = undefined;
    mask        : vector('n, dec, bool)     = undefined;

    (result, mask) = init_masked_result_cmp(num_elem, SEW, LMUL_pow, vd_val, vm_val);

    foreach (i from 0 to (num_elem - 1)) {
      if mask[i] then {
        let res : bool = match funct6 {
          VVCMP_VMSEQ    => vs2_val[i] == vs1_val[i],
          VVCMP_VMSNE    => vs2_val[i] != vs1_val[i],
          VVCMP_VMSLTU   => unsigned(vs2_val[i]) < unsigned(vs1_val[i]),
          VVCMP_VMSLT    => signed(vs2_val[i]) < signed(vs1_val[i]),
          VVCMP_VMSLEU   => unsigned(vs2_val[i]) <= unsigned(vs1_val[i]),
          VVCMP_VMSLE    => signed(vs2_val[i]) <= signed(vs1_val[i])
        };
        result[i] = res
      }
    };

    write_vmask(num_elem, vd, result);
    vstart = zeros();
    RETIRE_SUCCESS
  }
