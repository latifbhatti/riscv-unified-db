
%version: 1.0


U32 SEW = 32;
# U32 vstart = 0;                                  # from vcsr
# U32 M1 = 1;                                      #from vtype vcsr
U32 VLEN = 128 ;                                 #from config file
U32 ELEN = 32;                                   #from config file

Bits<32> elements_count = VLEN * VectorState.lmul/ VectorState.sew;


enum LMUL {
    M1_8  0b101
    M1_4  0b110
    M1_2  0b111
    M1    0b000
    M2    0b001
    M4    0b010
    M8    0b011
}

# ***************************  Mask Policy Handling  ****************************************
function handle_mask_policy_elementwise {
    returns U32
    arguments
        U32 original_value
    description {
        Determines the value for masked elements based on mask policy.
        Returns the original value if undisturbed, or all 1s if agnostic.
    }
    body {
        Bits<1> Mask_policy = 0 ; # from vtype vcsr
        if (Mask_policy == 0) {   # Mask undisturbed
            return original_value;
        } else {  # Mask agnostic
            return 0xFFFFFFFF;
        }
    }
}

# *********************************  Tail Element Handling  **************************************
function handle_tail_policy_elementwise {
    returns U32
    arguments
        U32 original_value
    description {
        Determines the value for tail elements based on the selected tail policy.
        Returns the original value if undisturbed, or all 1s if agnostic.
        Apply the tail policy when Vstart > vl.
    }
    body {
        Bits<1> TU = 0; # from vtype vcsr
        if (TU == 0) {  # Tail undisturbed
            return original_value;
        } else {  # Tail agnostic
            return 0xFFFFFFFF;  # All 1s pattern
        }
    }
}

# ***************************  Mask Policy Handling  ****************************************
function handle_mask_policy_bitwise {
    returns Bits<1>
    arguments
        Bits<1> original_value
    description {
        Determines the value for masked elements based on mask policy.
        Returns the original value if undisturbed, or all 1s if agnostic.
    }
    body {
        Bits<1> Mask_policy = 0 ; # from vtype vcsr
        if (Mask_policy == 0) {   # Mask undisturbed
            return original_value;
        } else {  # Mask agnostic
            return 1'b1;
        }
    }
}

# *********************************  Handle tail policy for comparison instructions.(bit wise)  **************************************
function handle_tail_policy_bitwise {
    returns Bits<1>
    arguments
        Bits<1> original_bit
    description {
        Determines the value for tail bits based on the selected tail policy.
        Returns the original value if undisturbed, or all 1s if agnostic.
        Apply the tail policy when Vstart > vl.
    }
    body {
        Bits<1> TU = 0; # from vtype vcsr
        if (TU == 0) {  # Tail undisturbed
            return original_bit;
        } else {  # Tail agnostic
            return 1'b1;
        }
    }
}

# perform operation on vector elements
function vector_comparison_instructions {
    returns Bits<1>
    arguments
        Bits<1> result,
        Bits<1> vs3_data,
        Bits<1> vs0_mask_bit,
        U32 encoding
    description {
        Incorporates masking logic and handles conditional execution based on mask bit 25.
        Checks the tail policy and applies either tail-agnostic or tail-undisturbed behavior accordingly.
        Returns the final processed 1-bit result after applying all vector rules.
        Implements tail policy when storing values in vector registers.
        Retains body Bits if within vector length (VL), otherwise applies tail policy.
    }
    body {
        U32 vstart = 0;  # from vcsr
        U32 vl = 4;      # from vcsr
        if (vstart <= vl){
            if (encoding[25] == 1) {  # Masking enabled
                if (vs0_mask_bit==1) {  # Active Bits
                    return result;
                } else {  # Masked Bits: apply mask policy
                    return handle_mask_policy_bitwise(vs3_data);
                }
            } else {  # Masking disabled
                return result;
            }
        }
        else {  # Tail Bits
            return handle_tail_policy_bitwise(result);
        }
    }
}


# perform operation on vector elements
function process_vector_elements {
    returns U32
    arguments
        U32 result,
        U32 vs3_data,
        Bits<1> vs0_mask_bit,
        U32 encoding
    description {
        Incorporates masking logic and handles conditional execution based on mask bit 25.
        Checks the tail policy and applies either tail-agnostic or tail-undisturbed behavior accordingly.
        Returns the final processed 32-bit result after applying all vector rules.
        Implements tail policy when storing values in vector registers.
        Retains body Elements if within vector length (VL), otherwise applies tail policy.
    }
    body {
        U32 vstart = 0;  # from vcsr
        U32 vl = 4;      # from vcsr
        if (vstart <= vl){
            if (encoding[25] == 1) {  # Masking enabled
                if (vs0_mask_bit==1) {  # Active element
                    return result;
                } else {  # Masked element: apply mask policy
                    return handle_mask_policy_elementwise(vs3_data);
                }
            } else {  # Masking disabled
                return result;
            }
        }
        else {  # Tail element
            return handle_tail_policy_elementwise(result);
        }
    }
}

function perform_vector_operation {
    returns U32
    arguments
        U32 result,
        U32 vs3_data,
        Bits<1> vs0_mask_bit,
        U32 encoding
    description {
        Performs vector operation based on input vector registers and mask.
        Accepts 2 data vectors elements (result, vs3) and a mask vector (vs0).
        The operation behavior is influenced by the mask instruction bit (bit 25).
    }
    body {
        return process_vector_elements(result,vs3_data,vs0_mask_bit,encoding);
    }
}

function get_vector_element {
    template
        U32 ELEMENT_SIZE
    returns
        Bits<ELEMENT_SIZE>
    arguments
        Bits<5> register_number,
        U32 element_number
    description {
        get vector element
    }
    body {
        Bits<32> start = ELEMENT_SIZE * element_number;
        return v[register_number][start:start + ELEMENT_SIZE];
  }
}
